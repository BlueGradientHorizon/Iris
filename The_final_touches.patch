Subject: [PATCH] The final touches
---
Index: common/src/main/java/net/irisshaders/iris/gl/program/IrisProgramTypes.java
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/gl/program/IrisProgramTypes.java b/common/src/main/java/net/irisshaders/iris/gl/program/IrisProgramTypes.java
deleted file mode 100644
--- a/common/src/main/java/net/irisshaders/iris/gl/program/IrisProgramTypes.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ /dev/null	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
@@ -1,9 +0,0 @@
-package net.irisshaders.iris.gl.program;
-
-import com.mojang.blaze3d.shaders.Program;
-
-public class IrisProgramTypes {
-	public static Program.Type GEOMETRY;
-	public static Program.Type TESS_CONTROL;
-	public static Program.Type TESS_EVAL;
-}
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinProgramManager.java
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinProgramManager.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinProgramManager.java
deleted file mode 100644
--- a/common/src/main/java/net/irisshaders/iris/mixin/MixinProgramManager.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ /dev/null	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
@@ -1,25 +0,0 @@
-package net.irisshaders.iris.mixin;
-
-import com.mojang.blaze3d.shaders.ProgramManager;
-import com.mojang.blaze3d.shaders.Shader;
-import net.irisshaders.iris.pipeline.programs.ExtendedShader;
-import org.spongepowered.asm.mixin.Mixin;
-import org.spongepowered.asm.mixin.injection.At;
-import org.spongepowered.asm.mixin.injection.Inject;
-import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
-
-@Mixin(ProgramManager.class)
-public class MixinProgramManager {
-	@Inject(method = "releaseProgram", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/systems/RenderSystem;assertOnRenderThread()V"))
-	private static void iris$releaseGeometry(Shader shader, CallbackInfo ci) {
-		if (shader instanceof ExtendedShader && ((ExtendedShader) shader).getGeometry() != null) {
-			((ExtendedShader) shader).getGeometry().close();
-		}
-		if (shader instanceof ExtendedShader && ((ExtendedShader) shader).getTessControl() != null) {
-			((ExtendedShader) shader).getTessControl().close();
-		}
-		if (shader instanceof ExtendedShader && ((ExtendedShader) shader).getTessEval() != null) {
-			((ExtendedShader) shader).getTessEval().close();
-		}
-	}
-}
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinProgramType.java
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinProgramType.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinProgramType.java
deleted file mode 100644
--- a/common/src/main/java/net/irisshaders/iris/mixin/MixinProgramType.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ /dev/null	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
@@ -1,35 +0,0 @@
-package net.irisshaders.iris.mixin;
-
-import com.mojang.blaze3d.shaders.Program;
-import net.irisshaders.iris.gl.program.IrisProgramTypes;
-import org.apache.commons.lang3.ArrayUtils;
-import org.lwjgl.opengl.GL32C;
-import org.lwjgl.opengl.GL42C;
-import org.spongepowered.asm.mixin.Final;
-import org.spongepowered.asm.mixin.Mixin;
-import org.spongepowered.asm.mixin.Mutable;
-import org.spongepowered.asm.mixin.Shadow;
-
-@Mixin(Program.Type.class)
-public class MixinProgramType {
-	@SuppressWarnings("target")
-	@Shadow
-	@Final
-	@Mutable
-	private static Program.Type[] $VALUES;
-
-	static {
-		int baseOrdinal = $VALUES.length;
-
-		IrisProgramTypes.GEOMETRY
-			= ProgramTypeAccessor.createProgramType("GEOMETRY", baseOrdinal, "geometry", ".gsh", GL32C.GL_GEOMETRY_SHADER);
-
-		IrisProgramTypes.TESS_CONTROL
-			= ProgramTypeAccessor.createProgramType("TESS_CONTROL", baseOrdinal + 1, "tess_control", ".tcs", GL42C.GL_TESS_CONTROL_SHADER);
-
-		IrisProgramTypes.TESS_EVAL
-			= ProgramTypeAccessor.createProgramType("TESS_EVAL", baseOrdinal + 2, "tess_eval", ".tes", GL42C.GL_TESS_EVALUATION_SHADER);
-
-		$VALUES = ArrayUtils.addAll($VALUES, IrisProgramTypes.GEOMETRY, IrisProgramTypes.TESS_CONTROL, IrisProgramTypes.TESS_EVAL);
-	}
-}
Index: common/src/main/java/net/irisshaders/iris/mixin/ProgramTypeAccessor.java
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/ProgramTypeAccessor.java b/common/src/main/java/net/irisshaders/iris/mixin/ProgramTypeAccessor.java
deleted file mode 100644
--- a/common/src/main/java/net/irisshaders/iris/mixin/ProgramTypeAccessor.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ /dev/null	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
@@ -1,13 +0,0 @@
-package net.irisshaders.iris.mixin;
-
-import com.mojang.blaze3d.shaders.Program;
-import org.spongepowered.asm.mixin.Mixin;
-import org.spongepowered.asm.mixin.gen.Invoker;
-
-@Mixin(Program.Type.class)
-public interface ProgramTypeAccessor {
-	@Invoker(value = "<init>")
-	static Program.Type createProgramType(String name, int ordinal, String typeName, String extension, int glId) {
-		throw new AssertionError();
-	}
-}
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer_SkipRendering.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer_SkipRendering.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer_SkipRendering.java
--- a/common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer_SkipRendering.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer_SkipRendering.java	(date 1724260419593)
@@ -63,22 +63,4 @@
 			return original.call(instance);
 		}
 	}
-
-	@WrapOperation(method = "renderBlockEntities", at = @At(value = "FIELD", target = "Lnet/minecraft/client/renderer/LevelRenderer;visibleSections:Lit/unimi/dsi/fastutil/objects/ObjectArrayList;"))
-	private ObjectArrayList<SectionRenderDispatcher.RenderSection> skipLocalBlockEntities(LevelRenderer instance, Operation<ObjectArrayList<SectionRenderDispatcher.RenderSection>> original) {
-		if (Iris.getPipelineManager().getPipelineNullable() instanceof IrisRenderingPipeline pipeline && pipeline.skipAllRendering()) {
-			return EMPTY_LIST;
-		} else {
-			return original.call(instance);
-		}
-	}
-
-	@WrapOperation(method = "renderBlockEntities", at = @At(value = "FIELD", target = "Lnet/minecraft/client/renderer/LevelRenderer;globalBlockEntities:Ljava/util/Set;"))
-	private Set<BlockEntity> skipGlobalBlockEntities(LevelRenderer instance, Operation<Set<BlockEntity>> original) {
-		if (Iris.getPipelineManager().getPipelineNullable() instanceof IrisRenderingPipeline pipeline && pipeline.skipAllRendering()) {
-			return Collections.emptySet();
-		} else {
-			return original.call(instance);
-		}
-	}
 }
Index: common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/shadow_map/MixinSodiumWorldRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/shadow_map/MixinSodiumWorldRenderer.java b/common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/shadow_map/MixinSodiumWorldRenderer.java
--- a/common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/shadow_map/MixinSodiumWorldRenderer.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/shadow_map/MixinSodiumWorldRenderer.java	(date 1724260713176)
@@ -79,7 +79,7 @@
 	}
 
 	@Inject(method = "isEntityVisible", at = @At("HEAD"), cancellable = true)
-	private void iris$overrideEntityCulling(Entity entity, EntityRenderer<Entity, EntityRenderState> renderer, CallbackInfoReturnable<Boolean> cir) {
+	private void iris$overrideEntityCulling(EntityRenderer<?, ?> renderer, Entity  entity, CallbackInfoReturnable<Boolean> cir) {
 		if (ShadowRenderingState.areShadowsCurrentlyBeingRendered()) cir.setReturnValue(true);
 	}
 
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinRenderSystem_Overrides.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinRenderSystem_Overrides.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinRenderSystem_Overrides.java
new file mode 100644
--- /dev/null	(date 1724271302236)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/MixinRenderSystem_Overrides.java	(date 1724271302236)
@@ -0,0 +1,175 @@
+package net.irisshaders.iris.mixin;
+
+import it.unimi.dsi.fastutil.Function;
+import it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap;
+import net.irisshaders.iris.Iris;
+import net.irisshaders.iris.pathways.HandRenderer;
+import net.irisshaders.iris.pipeline.IrisRenderingPipeline;
+import net.irisshaders.iris.pipeline.WorldRenderingPhase;
+import net.irisshaders.iris.pipeline.WorldRenderingPipeline;
+import net.irisshaders.iris.pipeline.programs.ShaderKey;
+import net.irisshaders.iris.pipeline.programs.ShaderOverrides;
+import net.irisshaders.iris.shadows.ShadowRenderingState;
+import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.renderer.CompiledShaderProgram;
+import net.minecraft.client.renderer.CoreShaders;
+import net.minecraft.client.renderer.ShaderManager;
+import net.minecraft.client.renderer.ShaderProgram;
+import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Unique;
+import org.spongepowered.asm.mixin.injection.At;
+import org.spongepowered.asm.mixin.injection.Inject;
+import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;
+
+import java.util.Map;
+
+import static net.irisshaders.iris.pipeline.programs.ShaderOverrides.isBlockEntities;
+
+@Mixin(ShaderManager.class)
+public class MixinRenderSystem_Overrides {
+	private static final Function<IrisRenderingPipeline, ShaderKey> FAKE_FUNCTION = p -> null;
+
+	@Unique
+	private static final Map<ShaderProgram, Function<IrisRenderingPipeline, ShaderKey>> coreShaderMap = new Object2ObjectArrayMap<>();
+	private static final Map<ShaderProgram, Function<IrisRenderingPipeline, ShaderKey>> coreShaderMapShadow = new Object2ObjectArrayMap<>();
+
+	static {
+		coreShaderMap.put(CoreShaders.POSITION, p -> ShaderOverrides.getSkyShader((IrisRenderingPipeline) p));
+		coreShaderMap.put(CoreShaders.POSITION_TEX, p -> ShaderOverrides.getSkyTexShader((IrisRenderingPipeline) p));
+		coreShaderMap.put(CoreShaders.POSITION_TEX_COLOR, p -> ShaderOverrides.getSkyTexColorShader((IrisRenderingPipeline) p));
+		coreShaderMap.put(CoreShaders.POSITION_COLOR, p -> ShaderOverrides.getSkyColorShader((IrisRenderingPipeline) p));
+		coreShaderMap.put(CoreShaders.PARTICLE, p -> ShaderOverrides.isPhase((IrisRenderingPipeline) p, WorldRenderingPhase.RAIN_SNOW) ? ShaderKey.WEATHER : ShaderKey.PARTICLES);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_CUTOUT, p -> getCutout(p));
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_SOLID, p -> isBlockEntities((IrisRenderingPipeline) p) ? ShaderKey.BLOCK_ENTITY : ShaderKey.ENTITIES_SOLID);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ARMOR_CUTOUT_NO_CULL, p -> getCutout(p));
+		coreShaderMap.put(CoreShaders.RENDERTYPE_GLINT, p -> ShaderKey.GLINT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_GLINT, p -> ShaderKey.GLINT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_GLINT_TRANSLUCENT, p -> ShaderKey.GLINT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ARMOR_ENTITY_GLINT, p -> ShaderKey.GLINT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_CUTOUT_NO_CULL, p -> getCutout(p));
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_CUTOUT_NO_CULL_Z_OFFSET, p -> getCutout(p));
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_SMOOTH_CUTOUT, p -> getCutout(p));
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_TRANSLUCENT, MixinRenderSystem_Overrides::getTranslucent);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_TRANSLUCENT_EMISSIVE, p -> ShaderKey.ENTITIES_EYES_TRANS);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_ALPHA, p -> ShaderKey.ENTITIES_ALPHA);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ITEM_ENTITY_TRANSLUCENT_CULL, MixinRenderSystem_Overrides::getTranslucent);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_SOLID, p -> ShaderKey.TERRAIN_SOLID);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_CUTOUT, p -> ShaderKey.TERRAIN_CUTOUT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_CUTOUT_MIPPED, p -> ShaderKey.TERRAIN_CUTOUT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_TRANSLUCENT, p -> ShaderOverrides.isBlockEntities((IrisRenderingPipeline) p) ? ShaderKey.MOVING_BLOCK : ShaderKey.TERRAIN_TRANSLUCENT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_TRIPWIRE, p -> ShaderKey.TERRAIN_TRANSLUCENT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_LINES, p -> ShaderKey.LINES);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_TEXT_BACKGROUND, p -> ShaderKey.TEXT_BG);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_TEXT_BACKGROUND_SEE_THROUGH, p -> ShaderKey.TEXT_BG);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_TEXT, p -> ShaderOverrides.isBlockEntities((IrisRenderingPipeline) p) ? ShaderKey.TEXT_BE : ShaderKey.TEXT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_TEXT_INTENSITY, p -> ShaderOverrides.isBlockEntities((IrisRenderingPipeline) p) ? ShaderKey.TEXT_INTENSITY_BE : ShaderKey.TEXT_INTENSITY);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_TEXT_INTENSITY_SEE_THROUGH, p -> ShaderOverrides.isBlockEntities((IrisRenderingPipeline) p) ? ShaderKey.TEXT_INTENSITY_BE : ShaderKey.TEXT_INTENSITY);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_EYES, p -> ShaderKey.ENTITIES_EYES);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENTITY_NO_OUTLINE, MixinRenderSystem_Overrides::getTranslucent);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_BREEZE_WIND, MixinRenderSystem_Overrides::getTranslucent);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_ENERGY_SWIRL, p -> ShaderKey.ENTITIES_CUTOUT);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_BEACON_BEAM, p -> ShaderKey.BEACON);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_LIGHTNING, p -> ShaderKey.LIGHTNING);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_END_PORTAL, MixinRenderSystem_Overrides::getCutout);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_END_GATEWAY, MixinRenderSystem_Overrides::getCutout);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_LEASH, p -> ShaderKey.LEASH);
+		coreShaderMap.put(CoreShaders.RENDERTYPE_WATER_MASK, p -> ShaderKey.ENTITIES_CUTOUT);
+
+		coreShaderMapShadow.put(CoreShaders.POSITION, p -> ShaderKey.SHADOW_BASIC);
+		coreShaderMapShadow.put(CoreShaders.POSITION_TEX, p -> ShaderKey.SHADOW_TEX);
+		coreShaderMapShadow.put(CoreShaders.POSITION_TEX_COLOR, p -> ShaderKey.SHADOW_TEX_COLOR);
+		coreShaderMapShadow.put(CoreShaders.POSITION_COLOR, p -> ShaderKey.SHADOW_BASIC_COLOR);
+		coreShaderMapShadow.put(CoreShaders.PARTICLE, p -> ShaderKey.SHADOW_PARTICLES);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_CUTOUT, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_SOLID, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ARMOR_CUTOUT_NO_CULL, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_GLINT, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_GLINT, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_GLINT_TRANSLUCENT, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ARMOR_ENTITY_GLINT, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_CUTOUT_NO_CULL, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_CUTOUT_NO_CULL_Z_OFFSET, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_SMOOTH_CUTOUT, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_TRANSLUCENT, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_TRANSLUCENT_EMISSIVE, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_ALPHA, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ITEM_ENTITY_TRANSLUCENT_CULL, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_SOLID, p -> ShaderKey.SHADOW_TERRAIN_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_CUTOUT, p -> ShaderKey.SHADOW_TERRAIN_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_CUTOUT_MIPPED, p -> ShaderKey.SHADOW_TERRAIN_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_TRANSLUCENT, p -> ShaderOverrides.isBlockEntities((IrisRenderingPipeline) p) ? ShaderKey.SHADOW_ENTITIES_CUTOUT : ShaderKey.SHADOW_TERRAIN_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_TRIPWIRE, p -> ShaderKey.SHADOW_TERRAIN_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_LINES, p -> ShaderKey.SHADOW_LINES);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_TEXT_BACKGROUND, p -> ShaderKey.SHADOW_TEXT_BG);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_TEXT_BACKGROUND_SEE_THROUGH, p -> ShaderKey.SHADOW_TEXT_BG);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_TEXT, p -> ShaderKey.SHADOW_TEXT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_TEXT_INTENSITY, p -> ShaderKey.SHADOW_TEXT_INTENSITY);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_TEXT_INTENSITY_SEE_THROUGH, p -> ShaderKey.SHADOW_TEXT_INTENSITY);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_EYES, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENTITY_NO_OUTLINE, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_BREEZE_WIND, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_ENERGY_SWIRL, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_BEACON_BEAM, p -> ShaderKey.SHADOW_BEACON_BEAM);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_LIGHTNING, p -> ShaderKey.SHADOW_LIGHTNING);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_END_PORTAL, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_END_GATEWAY, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_LEASH, p -> ShaderKey.SHADOW_LEASH);
+		coreShaderMapShadow.put(CoreShaders.RENDERTYPE_WATER_MASK, p -> ShaderKey.SHADOW_ENTITIES_CUTOUT);
+
+		// Check that all shaders are accounted for
+		for (ShaderProgram program : CoreShaders.getProgramsToPreload()) {
+			if (coreShaderMap.containsKey(program) && !coreShaderMapShadow.containsKey(program)) {
+				throw new IllegalStateException("Shader program " + program + " is not accounted for in the shadow list");
+			}
+		}
+	}
+
+	private static ShaderKey getCutout(Object p) {
+		IrisRenderingPipeline pipeline = (IrisRenderingPipeline) p;
+
+		if (HandRenderer.INSTANCE.isActive()) {
+			return (HandRenderer.INSTANCE.isRenderingSolid() ? ShaderKey.HAND_CUTOUT_DIFFUSE : ShaderKey.HAND_WATER_DIFFUSE);
+		} else if (isBlockEntities(pipeline)) {
+			return (ShaderKey.BLOCK_ENTITY_DIFFUSE);
+		} else {
+			return (ShaderKey.ENTITIES_CUTOUT_DIFFUSE);
+		}
+	}
+
+	private static ShaderKey getTranslucent(Object p) {
+		IrisRenderingPipeline pipeline = (IrisRenderingPipeline) p;
+
+		if (HandRenderer.INSTANCE.isActive()) {
+			return (HandRenderer.INSTANCE.isRenderingSolid() ? ShaderKey.HAND_CUTOUT_DIFFUSE : ShaderKey.HAND_WATER_DIFFUSE);
+		} else if (isBlockEntities(pipeline)) {
+			return (ShaderKey.BLOCK_ENTITY);
+		} else {
+			return (ShaderKey.ENTITIES_TRANSLUCENT);
+		}
+	}
+
+	@Inject(method = "getProgram", at = @At(value = "HEAD"), cancellable = true)
+	private void redirectIrisProgram(ShaderProgram shaderProgram, CallbackInfoReturnable<CompiledShaderProgram> cir) {
+		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
+
+		if (pipeline instanceof IrisRenderingPipeline irisPipeline && irisPipeline.shouldOverrideShaders()) {
+			CompiledShaderProgram program = override(irisPipeline, shaderProgram);
+
+			if (program != null) {
+				cir.setReturnValue(program);
+			} else if (Screen.hasAltDown()) 	{
+				System.out.println("We have a " + (ShadowRenderingState.areShadowsCurrentlyBeingRendered() ? "shadow " : "") + "program that can't be found; " + shaderProgram.configId());
+			}
+		}
+	}
+
+	private static CompiledShaderProgram override(IrisRenderingPipeline pipeline, ShaderProgram shaderProgram) {
+		ShaderKey shaderKey = convertToShaderKey(pipeline, shaderProgram);
+
+		return shaderKey == null ? null : pipeline.getShaderMap().getShader(shaderKey);
+	}
+
+	private static ShaderKey convertToShaderKey(IrisRenderingPipeline pipeline, ShaderProgram shaderProgram) {
+		return ShadowRenderingState.areShadowsCurrentlyBeingRendered()? coreShaderMapShadow.getOrDefault(shaderProgram, FAKE_FUNCTION).apply(pipeline) : coreShaderMap.getOrDefault(shaderProgram, FAKE_FUNCTION).apply(pipeline);
+	}
+}
Index: common/src/main/java/net/irisshaders/iris/pathways/HorizonRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pathways/HorizonRenderer.java b/common/src/main/java/net/irisshaders/iris/pathways/HorizonRenderer.java
--- a/common/src/main/java/net/irisshaders/iris/pathways/HorizonRenderer.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/pathways/HorizonRenderer.java	(date 1724265158763)
@@ -8,7 +8,7 @@
 import com.mojang.blaze3d.vertex.VertexConsumer;
 import com.mojang.blaze3d.vertex.VertexFormat;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.renderer.ShaderInstance;
+import net.minecraft.client.renderer.ShaderProgram;
 import org.joml.Matrix4f;
 import org.joml.Matrix4fc;
 
@@ -154,14 +154,14 @@
 		buildBottomPlane(consumer, 384);
 	}
 
-	public void renderHorizon(Matrix4fc modelView, Matrix4fc projection, ShaderInstance shader) {
+	public void renderHorizon(Matrix4fc modelView, Matrix4fc projection, ShaderProgram shader) {
 		if (currentRenderDistance != Minecraft.getInstance().options.getEffectiveRenderDistance()) {
 			currentRenderDistance = Minecraft.getInstance().options.getEffectiveRenderDistance();
 			rebuildBuffer();
 		}
 
 		buffer.bind();
-		buffer.drawWithShader(new Matrix4f(modelView), new Matrix4f(projection), shader);
+		buffer.drawWithShader(new Matrix4f(modelView), new Matrix4f(projection), Minecraft.getInstance().getShaderManager().getProgram(shader));
 		VertexBuffer.unbind();
 	}
 
Index: common/src/main/java/net/irisshaders/iris/pathways/LightningHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pathways/LightningHandler.java b/common/src/main/java/net/irisshaders/iris/pathways/LightningHandler.java
--- a/common/src/main/java/net/irisshaders/iris/pathways/LightningHandler.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/pathways/LightningHandler.java	(date 1724260250786)
@@ -29,23 +29,7 @@
 			.createCompositeState(false)
 	), new LightningRenderStateShard());
 
-	public static final Function<ResourceLocation, RenderType> MEKANISM_FLAME = Util.memoize(resourceLocation -> {
-		RenderType.CompositeState state = RenderType.CompositeState.builder()
-			.setShaderState(new ShaderStateShard(ShaderAccess::getMekanismFlameShader))
-			.setTextureState(new RenderStateShard.TextureStateShard(resourceLocation, TriState.DEFAULT, false))
-			.setTransparencyState(TRANSLUCENT_TRANSPARENCY)
-			.createCompositeState(true);
-		return create("mek_flame", DefaultVertexFormat.POSITION_TEX_COLOR, VertexFormat.Mode.QUADS, 256, true, false, state);
-	});
-
-	public static final RenderType MEKASUIT = create("mekasuit", DefaultVertexFormat.NEW_ENTITY, VertexFormat.Mode.QUADS, 131_072, true, false,
-		RenderType.CompositeState.builder()
-			.setShaderState(new ShaderStateShard(ShaderAccess::getMekasuitShader))
-			.setTextureState(BLOCK_SHEET)
-			.setLightmapState(LIGHTMAP)
-			.setOverlayState(OVERLAY)
-			.createCompositeState(true)
-	);
+	// TODO MEKANISM AGAIN 24w34a
 
 	public LightningHandler(String pRenderType0, VertexFormat pVertexFormat1, VertexFormat.Mode pVertexFormat$Mode2, int pInt3, boolean pBoolean4, boolean pBoolean5, Runnable pRunnable6, Runnable pRunnable7) {
 		super(pRenderType0, pVertexFormat1, pVertexFormat$Mode2, pInt3, pBoolean4, pBoolean5, pRunnable6, pRunnable7);
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinProgram.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinProgram.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinProgram.java
--- a/common/src/main/java/net/irisshaders/iris/mixin/MixinProgram.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/MixinProgram.java	(date 1724260186579)
@@ -2,7 +2,7 @@
 
 import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.preprocessor.GlslPreprocessor;
-import com.mojang.blaze3d.shaders.Program;
+import net.irisshaders.iris.gl.program.Program;
 import net.irisshaders.iris.gl.shader.ShaderCompileException;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.injection.At;
@@ -17,22 +17,5 @@
 
 @Mixin(Program.class)
 public class MixinProgram {
-	@Redirect(method = "compileShaderInternal", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/preprocessor/GlslPreprocessor;process(Ljava/lang/String;)Ljava/util/List;"))
-	private static List<String> iris$allowSkippingMojImportDirectives(GlslPreprocessor includeHandler, String shaderSource) {
-		// Mojang's code for handling #moj_import directives uses regexes that can cause StackOverflowErrors.
-		//
-		// Rather than fix the crash, we just don't try to process directives if they don't exist, which is fine
-		// for Iris since we don't allow using moj_import.
-		if (!shaderSource.contains("moj_import")) {
-			return Collections.singletonList(shaderSource);
-		}
 
-		return includeHandler.process(shaderSource);
-	}
-
-	@Inject(method = "compileShaderInternal", at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/platform/GlStateManager;glGetShaderInfoLog(II)Ljava/lang/String;"), locals = LocalCapture.CAPTURE_FAILHARD, cancellable = true)
-	private static void iris$causeException(Program.Type arg, String string, InputStream inputStream, String string2, GlslPreprocessor arg2, CallbackInfoReturnable<Integer> cir, String string3, int i) {
-		cir.cancel();
-		throw new ShaderCompileException(string + arg.getExtension(), GlStateManager.glGetShaderInfoLog(i, 32768));
-	}
 }
Index: common/src/main/java/net/irisshaders/iris/pipeline/IrisRenderingPipeline.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pipeline/IrisRenderingPipeline.java b/common/src/main/java/net/irisshaders/iris/pipeline/IrisRenderingPipeline.java
--- a/common/src/main/java/net/irisshaders/iris/pipeline/IrisRenderingPipeline.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/pipeline/IrisRenderingPipeline.java	(date 1724259927756)
@@ -88,9 +88,10 @@
 import net.irisshaders.iris.uniforms.custom.CustomUniforms;
 import net.minecraft.client.Camera;
 import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.CompiledShaderProgram;
+import net.minecraft.client.renderer.CoreShaders;
 import net.minecraft.client.renderer.DimensionSpecialEffects;
 import net.minecraft.client.renderer.GameRenderer;
-import net.minecraft.client.renderer.ShaderInstance;
 import net.minecraft.client.renderer.texture.AbstractTexture;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import org.apache.commons.lang3.StringUtils;
@@ -125,7 +126,7 @@
 	private final boolean separateHardwareSamplers;
 	private final ProgramFallbackResolver resolver;
 	private final Supplier<ShadowRenderTargets> shadowTargetsSupplier;
-	private final Set<ShaderInstance> loadedShaders;
+	private final Set<CompiledShaderProgram> loadedShaders;
 	private final CompositeRenderer beginRenderer;
 	private final CompositeRenderer prepareRenderer;
 	private final CompositeRenderer deferredRenderer;
@@ -455,7 +456,7 @@
 		WorldRenderingSettings.INSTANCE.setUseExtendedVertexFormat(true);
 
 		if (shadowRenderTargets != null) {
-			ShaderInstance shader = shaderMap.getShader(ShaderKey.SHADOW_TERRAIN_CUTOUT);
+			CompiledShaderProgram shader = shaderMap.getShader(ShaderKey.SHADOW_TERRAIN_CUTOUT);
 			boolean shadowUsesImages = false;
 
 			if (shader instanceof ExtendedShader shader2) {
@@ -672,7 +673,7 @@
 		return programs;
 	}
 
-	private ShaderInstance createShader(String name, Optional<ProgramSource> source, ShaderKey key) throws IOException {
+	private CompiledShaderProgram createShader(String name, Optional<ProgramSource> source, ShaderKey key) throws IOException {
 		if (!source.isPresent()) {
 			return createFallbackShader(name, key);
 		}
@@ -686,7 +687,7 @@
 		return customTextureMap;
 	}
 
-	private ShaderInstance createShader(String name, ProgramSource source, ProgramId programId, AlphaTest fallbackAlpha,
+	private CompiledShaderProgram createShader(String name, ProgramSource source, ProgramId programId, AlphaTest fallbackAlpha,
 										VertexFormat vertexFormat, FogMode fogMode,
 										boolean isIntensity, boolean isFullbright, boolean isGlint, boolean isText, boolean isIE) throws IOException {
 		GlFramebuffer beforeTranslucent = renderTargets.createGbufferFramebuffer(flippedAfterPrepare, source.getDirectives().getDrawBuffers());
@@ -708,7 +709,7 @@
 		return extendedShader;
 	}
 
-	private ShaderInstance createFallbackShader(String name, ShaderKey key) throws IOException {
+	private CompiledShaderProgram createFallbackShader(String name, ShaderKey key) throws IOException {
 		GlFramebuffer beforeTranslucent = renderTargets.createGbufferFramebuffer(flippedAfterPrepare, new int[]{0});
 		GlFramebuffer afterTranslucent = renderTargets.createGbufferFramebuffer(flippedAfterTranslucent, new int[]{0});
 
@@ -721,7 +722,7 @@
 		return shader;
 	}
 
-	private ShaderInstance createShadowShader(String name, Optional<ProgramSource> source, ShaderKey key) throws IOException {
+	private CompiledShaderProgram createShadowShader(String name, Optional<ProgramSource> source, ShaderKey key) throws IOException {
 		if (!source.isPresent()) {
 			return createFallbackShadowShader(name, key);
 		}
@@ -730,7 +731,7 @@
 			key.isIntensity(), key.shouldIgnoreLightmap(), key.isText(), key == ShaderKey.IE_COMPAT_SHADOW);
 	}
 
-	private ShaderInstance createFallbackShadowShader(String name, ShaderKey key) throws IOException {
+	private CompiledShaderProgram createFallbackShadowShader(String name, ShaderKey key) throws IOException {
 		GlFramebuffer framebuffer = shadowRenderTargets.createShadowFramebuffer(ImmutableSet.of(), new int[]{0});
 
 		FallbackShader shader = ShaderCreator.createFallback(name, framebuffer, framebuffer,
@@ -742,7 +743,7 @@
 		return shader;
 	}
 
-	private ShaderInstance createShadowShader(String name, ProgramSource source, ProgramId programId, AlphaTest fallbackAlpha,
+	private CompiledShaderProgram createShadowShader(String name, ProgramSource source, ProgramId programId, AlphaTest fallbackAlpha,
 											  VertexFormat vertexFormat, boolean isIntensity, boolean isFullbright, boolean isText, boolean isIE) throws IOException {
 		GlFramebuffer framebuffer = shadowRenderTargets.createShadowFramebuffer(ImmutableSet.of(), source.getDirectives().hasUnknownDrawBuffers() ? new int[]{0, 1} : source.getDirectives().getDrawBuffers());
 		boolean isLines = programId == ProgramId.Line && resolver.has(ProgramId.Line);
@@ -1008,7 +1009,7 @@
 
 			RenderSystem.setShaderColor(fogColor.x, fogColor.y, fogColor.z, fogColor.w);
 
-			horizonRenderer.renderHorizon(CapturedRenderingState.INSTANCE.getGbufferModelView(), CapturedRenderingState.INSTANCE.getGbufferProjection(), GameRenderer.getPositionShader());
+			horizonRenderer.renderHorizon(CapturedRenderingState.INSTANCE.getGbufferModelView(), CapturedRenderingState.INSTANCE.getGbufferProjection(), CoreShaders.POSITION);
 
 			RenderSystem.depthMask(true);
 
@@ -1076,7 +1077,7 @@
 		// Not good!
 
 		// Reset shader or whatever...
-		RenderSystem.setShader(GameRenderer::getPositionShader);
+		RenderSystem.setShader(CoreShaders.POSITION);
 	}
 
 	@Override
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinTheEndPortalRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinTheEndPortalRenderer.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinTheEndPortalRenderer.java
--- a/common/src/main/java/net/irisshaders/iris/mixin/MixinTheEndPortalRenderer.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/MixinTheEndPortalRenderer.java	(date 1724270208883)
@@ -39,7 +39,7 @@
 		return 0.375F;
 	}
 
-	@Inject(method = "render", at = @At("HEAD"), cancellable = true)
+	@Inject(method = "render(Lnet/minecraft/world/level/block/entity/TheEndPortalBlockEntity;FLcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource;II)V", at = @At("HEAD"), cancellable = true)
 	public void iris$onRender(TheEndPortalBlockEntity entity, float tickDelta, PoseStack poseStack, MultiBufferSource multiBufferSource, int light, int overlay, CallbackInfo ci) {
 		if (!Iris.getCurrentPack().isPresent()) {
 			return;
Index: common/src/main/resources/iris.accesswidener
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/iris.accesswidener b/common/src/main/resources/iris.accesswidener
--- a/common/src/main/resources/iris.accesswidener	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/resources/iris.accesswidener	(date 1724261926399)
@@ -5,6 +5,7 @@
 accessible  class   com/mojang/blaze3d/platform/GlStateManager$TextureState
 accessible  class   com/mojang/blaze3d/platform/GlStateManager$ColorMask
 accessible  class   com/mojang/blaze3d/platform/GlStateManager$DepthState
+accessible method net/minecraft/client/renderer/CompiledShaderProgram <init> (I)V
 accessible  class   net/minecraft/client/renderer/RenderStateShard$TransparencyStateShard
 accessible  class   net/minecraft/client/renderer/RenderType$CompositeRenderType
 accessible  class   net/minecraft/client/renderer/RenderType$CompositeState
@@ -17,18 +18,16 @@
 accessible class net/minecraft/client/renderer/texture/SpriteContents$Ticker
 accessible  class   net/minecraft/client/OptionInstance$ValueSet
 extendable  class   net/minecraft/client/OptionInstance
+accessible field net/minecraft/client/renderer/CompiledShaderProgram uniformsByName Ljava/util/Map;
+accessible method net/minecraft/client/renderer/CompiledShaderProgram parseUniformNode (Lnet/minecraft/client/renderer/ShaderProgramConfig$Uniform;)Lcom/mojang/blaze3d/shaders/Uniform;
+accessible field net/minecraft/client/renderer/CompiledShaderProgram samplers Ljava/util/List;
+accessible field net/minecraft/client/renderer/CompiledShaderProgram samplerLocations Lit/unimi/dsi/fastutil/ints/IntList;
+accessible field net/minecraft/client/renderer/CompiledShaderProgram uniforms Ljava/util/List;
 accessible  class   net/minecraft/client/renderer/chunk/SectionRenderDispatcher$RenderSection$RebuildTask
 extendable  class   net/minecraft/core/RegistryAccess$RegistryEntry
 accessible method net/minecraft/client/renderer/RenderType create (Ljava/lang/String;Lcom/mojang/blaze3d/vertex/VertexFormat;Lcom/mojang/blaze3d/vertex/VertexFormat$Mode;IZZLnet/minecraft/client/renderer/RenderType$CompositeState;)Lnet/minecraft/client/renderer/RenderType$CompositeRenderType;
 accessible field com/mojang/blaze3d/platform/NativeImage pixels J
-mutable field net/minecraft/client/renderer/ShaderInstance PROJECTION_MATRIX Lcom/mojang/blaze3d/shaders/Uniform;
-mutable field net/minecraft/client/renderer/ShaderInstance MODEL_VIEW_MATRIX Lcom/mojang/blaze3d/shaders/Uniform;
-mutable field net/minecraft/client/renderer/ShaderInstance TEXTURE_MATRIX Lcom/mojang/blaze3d/shaders/Uniform;
-mutable field net/minecraft/client/renderer/ShaderInstance MODEL_OFFSET Lcom/mojang/blaze3d/shaders/Uniform;
-mutable field net/minecraft/client/renderer/ShaderInstance COLOR_MODULATOR Lcom/mojang/blaze3d/shaders/Uniform;
-accessible field net/minecraft/client/renderer/ShaderInstance uniforms Ljava/util/List;
 mutable field net/minecraft/client/renderer/LevelRenderer renderBuffers Lnet/minecraft/client/renderer/RenderBuffers;
 accessible class net/minecraft/client/gui/components/AbstractSelectionList$Entry
 accessible field com/mojang/blaze3d/platform/GlStateManager$BooleanState enabled Z
-accessible method com/mojang/blaze3d/shaders/Program getId ()I
 accessible field com/mojang/blaze3d/vertex/PoseStack$Pose trustedNormals Z
Index: common/src/main/java/net/irisshaders/iris/gui/screen/ShaderPackScreen.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/gui/screen/ShaderPackScreen.java b/common/src/main/java/net/irisshaders/iris/gui/screen/ShaderPackScreen.java
--- a/common/src/main/java/net/irisshaders/iris/gui/screen/ShaderPackScreen.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/gui/screen/ShaderPackScreen.java	(date 1724260292439)
@@ -27,10 +27,12 @@
 import net.minecraft.client.gui.screens.ConfirmLinkScreen;
 import net.minecraft.client.gui.screens.ConfirmScreen;
 import net.minecraft.client.gui.screens.Screen;
+import net.minecraft.client.renderer.LevelTargetBundle;
 import net.minecraft.client.renderer.PostChain;
 import net.minecraft.network.chat.CommonComponents;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.util.FormattedCharSequence;
 import org.jetbrains.annotations.Nullable;
 import org.lwjgl.glfw.GLFW;
@@ -61,6 +63,7 @@
 	private static final Component CONFIGURE_TITLE = Component.translatable("pack.iris.configure.title").withStyle(ChatFormatting.GRAY, ChatFormatting.ITALIC);
 	private static final int COMMENT_PANEL_WIDTH = 314;
 	private static final String development = "Development Environment";
+	private static final ResourceLocation BLUR_POST_CHAIN_ID = ResourceLocation.withDefaultNamespace("blur");
 	private final Screen parent;
 	private final MutableComponent irisTextComponent;
 	private ShaderPackSelectionList shaderPackList;
@@ -360,11 +363,11 @@
 	}
 
 	private void processFixedBlur() {
-		PostChain blurEffect = ((GameRendererAccessor) this.minecraft.gameRenderer).getBlurEffect();
+		PostChain blurEffect = this.minecraft.getShaderManager().getPostChain(BLUR_POST_CHAIN_ID, LevelTargetBundle.MAIN_TARGETS);
 		float g = (float) Math.min(this.minecraft.options.getMenuBackgroundBlurriness(), this.blurTransition.getAsFloat());
 		if (blurEffect != null && g >= 1.0F) {
 			blurEffect.setUniform("Radius", g);
-			blurEffect.process(Minecraft.getInstance().getMainRenderTarget(), ((GameRendererAccessor) this.minecraft.gameRenderer).getResourcePool(), this.minecraft.getDeltaTracker());
+			blurEffect.process(Minecraft.getInstance().getMainRenderTarget(), ((GameRendererAccessor) this.minecraft.gameRenderer).getResourcePool());
 		}
 	}
 
Index: build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle.kts b/build.gradle.kts
--- a/build.gradle.kts	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/build.gradle.kts	(date 1724258347136)
@@ -4,11 +4,11 @@
     id("fabric-loom") version("1.7.2") apply(false)
 }
 
-val MINECRAFT_VERSION by extra { "24w33a" }
+val MINECRAFT_VERSION by extra { "24w34a" }
 val NEOFORGE_VERSION by extra { "21.0.143" }
-val FABRIC_LOADER_VERSION by extra { "0.16.1" }
+val FABRIC_LOADER_VERSION by extra { "0.16.2" }
 val FABRIC_API_VERSION by extra { "0.102.0+1.21.1" }
-val SODIUM_FILE by extra { "sodium-LOADER-0.6.0-snapshot+mc24w33a-local.jar" }
+val SODIUM_FILE by extra { "sodium-fabric-0.6.0-snapshot+mc24w34a-local.jar" }
 
 // https://semver.org/
 val MOD_VERSION by extra { "1.8.0" }
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinShaderInstance.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinShaderInstance.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinShaderInstance.java
--- a/common/src/main/java/net/irisshaders/iris/mixin/MixinShaderInstance.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/MixinShaderInstance.java	(date 1724260104949)
@@ -1,7 +1,6 @@
 package net.irisshaders.iris.mixin;
 
 import com.google.common.collect.ImmutableSet;
-import com.mojang.blaze3d.shaders.Program;
 import com.mojang.blaze3d.shaders.Uniform;
 import com.mojang.blaze3d.vertex.VertexFormat;
 import net.irisshaders.iris.Iris;
@@ -12,7 +11,7 @@
 import net.irisshaders.iris.pipeline.programs.ExtendedShader;
 import net.irisshaders.iris.pipeline.programs.FallbackShader;
 import net.irisshaders.iris.mixinterface.ShaderInstanceInterface;
-import net.minecraft.client.renderer.ShaderInstance;
+import net.minecraft.client.renderer.CompiledShaderProgram;
 import net.minecraft.server.packs.resources.ResourceProvider;
 import org.lwjgl.opengl.KHRDebug;
 import org.slf4j.Logger;
@@ -25,11 +24,14 @@
 import org.spongepowered.asm.mixin.injection.Redirect;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
-@Mixin(ShaderInstance.class)
+@Mixin(CompiledShaderProgram.class)
 public abstract class MixinShaderInstance implements ShaderInstanceInterface {
 	@Unique
 	private static final ImmutableSet<String> ATTRIBUTE_LIST = ImmutableSet.of("Position", "Color", "Normal", "UV0", "UV1", "UV2");
 
+	@Unique
+	private CompiledShaderProgram lastAppliedShader;
+
 	private static boolean shouldOverrideShaders() {
 		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
 
@@ -40,56 +42,27 @@
 		}
 	}
 
-	@Shadow
-	public abstract int getId();
-
 	@Shadow
 	@Final
 	private int programId;
 
-	@Shadow
-	@Final
-	private Program vertexProgram;
-
-	@Shadow
-	@Final
-	private Program fragmentProgram;
-
-	@Shadow
-	private static ShaderInstance lastAppliedShader;
-
-	@Redirect(method = "updateLocations",
-		at = @At(value = "INVOKE", target = "Lorg/slf4j/Logger;warn(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V", remap = false))
-	private void iris$redirectLogSpam(Logger logger, String message, Object arg1, Object arg2) {
-		if (((Object) this) instanceof ExtendedShader || ((Object) this) instanceof FallbackShader) {
-			return;
-		}
-
-		logger.warn(message, arg1, arg2);
-	}
-
-	@Redirect(method = "<init>*", require = 1, at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/shaders/Uniform;glBindAttribLocation(IILjava/lang/CharSequence;)V"))
+	// TODO IMS 24w34a
+	/*@Redirect(method = "<init>*", require = 1, at = @At(value = "INVOKE", target = "Lcom/mojang/blaze3d/shaders/Uniform;glBindAttribLocation(IILjava/lang/CharSequence;)V"))
 	public void iris$redirectBindAttributeLocation(int i, int j, CharSequence charSequence) {
 		if (((Object) this) instanceof ExtendedShader && ATTRIBUTE_LIST.contains(charSequence)) {
 			Uniform.glBindAttribLocation(i, j, "iris_" + charSequence);
 		} else {
 			Uniform.glBindAttribLocation(i, j, charSequence);
 		}
-	}
-
-	@Inject(method = "<init>", at = @At("RETURN"))
-	private void name(ResourceProvider resourceProvider, String string, VertexFormat vertexFormat, CallbackInfo ci) {
-		GLDebug.nameObject(KHRDebug.GL_PROGRAM, this.programId, string);
-		GLDebug.nameObject(KHRDebug.GL_SHADER, this.vertexProgram.getId(), string);
-		GLDebug.nameObject(KHRDebug.GL_SHADER, this.fragmentProgram.getId(), string);
-	}
+	}*/
 
 	@Inject(method = "apply", at = @At("HEAD"))
 	private void iris$lockDepthColorState(CallbackInfo ci) {
 		if (lastAppliedShader != null) {
 			lastAppliedShader.clear();
-			lastAppliedShader = null;
 		}
+
+		lastAppliedShader = ((CompiledShaderProgram) (Object) this);
 	}
 
 	@Inject(method = "apply", at = @At("TAIL"))
@@ -104,20 +77,12 @@
 
 	@Inject(method = "clear", at = @At("HEAD"))
 	private void iris$unlockDepthColorState(CallbackInfo ci) {
+		lastAppliedShader = null;
+
 		if (((Object) this) instanceof ExtendedShader || ((Object) this) instanceof FallbackShader || !shouldOverrideShaders()) {
 			return;
 		}
 
 		DepthColorStorage.unlockDepthColor();
 	}
-
-	@Inject(method = "<init>", require = 0, at = @At(value = "INVOKE", target = "Lnet/minecraft/util/GsonHelper;parse(Ljava/io/Reader;)Lcom/google/gson/JsonObject;"))
-	public void iris$setupGeometryShader(ResourceProvider resourceProvider, String string, VertexFormat vertexFormat, CallbackInfo ci) {
-		this.iris$createExtraShaders(resourceProvider, string);
-	}
-
-	@Override
-	public void iris$createExtraShaders(ResourceProvider provider, String name) {
-		//no-op, used for ExtendedShader to call before the super constructor
-	}
 }
Index: common/src/main/java/net/irisshaders/iris/pipeline/programs/ExtendedShader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ExtendedShader.java b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ExtendedShader.java
--- a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ExtendedShader.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ExtendedShader.java	(date 1724262860073)
@@ -1,8 +1,8 @@
 package net.irisshaders.iris.pipeline.programs;
 
+import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.preprocessor.GlslPreprocessor;
-import com.mojang.blaze3d.shaders.Program;
-import com.mojang.blaze3d.shaders.ProgramManager;
+import com.mojang.blaze3d.shaders.CompiledShader;
 import com.mojang.blaze3d.shaders.Uniform;
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.mojang.blaze3d.vertex.VertexFormat;
@@ -14,7 +14,6 @@
 import net.irisshaders.iris.gl.blending.BufferBlendOverride;
 import net.irisshaders.iris.gl.framebuffer.GlFramebuffer;
 import net.irisshaders.iris.gl.image.ImageHolder;
-import net.irisshaders.iris.gl.program.IrisProgramTypes;
 import net.irisshaders.iris.gl.program.ProgramImages;
 import net.irisshaders.iris.gl.program.ProgramSamplers;
 import net.irisshaders.iris.gl.program.ProgramUniforms;
@@ -28,7 +27,8 @@
 import net.irisshaders.iris.uniforms.custom.CustomUniforms;
 import net.irisshaders.iris.vertices.ImmediateState;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.renderer.ShaderInstance;
+import net.minecraft.client.renderer.CompiledShaderProgram;
+import net.minecraft.client.renderer.ShaderProgramConfig;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.resources.ResourceProvider;
 import org.jetbrains.annotations.NotNull;
@@ -40,11 +40,13 @@
 import org.lwjgl.opengl.KHRDebug;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 
-public class ExtendedShader extends ShaderInstance implements ShaderInstanceInterface {
+public class ExtendedShader extends CompiledShaderProgram implements ShaderInstanceInterface {
 	private static final Matrix4f identity;
 	private static ExtendedShader lastApplied;
 
@@ -73,19 +75,27 @@
 	private final Matrix3f tempMatrix3f = new Matrix3f();
 	private final float[] tempFloats = new float[16];
 	private final float[] tempFloats2 = new float[9];
-	private Program geometry, tessControl, tessEval;
+	private CompiledShader geometry, tessControl, tessEval;
 
-	public ExtendedShader(ResourceProvider resourceFactory, String string, VertexFormat vertexFormat, boolean usesTessellation,
+	public ExtendedShader(int programId, ResourceProvider resourceFactory, String string, VertexFormat vertexFormat, boolean usesTessellation,
 						  GlFramebuffer writingToBeforeTranslucent, GlFramebuffer writingToAfterTranslucent,
 						  BlendModeOverride blendModeOverride, AlphaTest alphaTest,
 						  Consumer<DynamicLocationalUniformHolder> uniformCreator, BiConsumer<SamplerHolder, ImageHolder> samplerCreator, boolean isIntensity,
 						  IrisRenderingPipeline parent, @Nullable List<BufferBlendOverride> bufferBlendOverrides, CustomUniforms customUniforms) throws IOException {
-		super(resourceFactory, string, vertexFormat);
+		super(programId);
 
-		GLDebug.nameObject(KHRDebug.GL_SHADER, this.getVertexProgram().getId(), string + "_vertex.vsh");
-		GLDebug.nameObject(KHRDebug.GL_SHADER, this.getFragmentProgram().getId(), string + "_fragment.fsh");
+		List<ShaderProgramConfig.Uniform> uniformList = new ArrayList<>();
+		List<ShaderProgramConfig.Sampler> samplerList = new ArrayList<>();
+		uniformList.add(new ShaderProgramConfig.Uniform("iris_ModelViewMat", "matrix4x4", 16, List.of(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f)));
+		uniformList.add(new ShaderProgramConfig.Uniform("iris_NormalMat", "matrix3x3", 9, List.of(1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f)));
+		uniformList.add(new ShaderProgramConfig.Uniform("iris_ProjMat", "matrix4x4", 16, List.of(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f)));
+		uniformList.add(new ShaderProgramConfig.Uniform("iris_TextureMat", "matrix4x4", 16, List.of(1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f)));
+		uniformList.add(new ShaderProgramConfig.Uniform("iris_ColorModulator", "float", 4, List.of(1.0f, 1.0f, 1.0f, 1.0f)));
+		uniformList.add(new ShaderProgramConfig.Uniform("iris_ModelOffset", "float", 3, List.of(0.0f, 0.0f, 0.0f)));
 
-		int programId = this.getId();
+		samplerList.add(new ShaderProgramConfig.Sampler("Sampler0"));
+		setupUniforms(uniformList, samplerList);
+
 
 		GLDebug.nameObject(KHRDebug.GL_PROGRAM, programId, string);
 
@@ -139,8 +149,12 @@
 
 		if (lastApplied != this) {
 			lastApplied = this;
-			ProgramManager.glUseProgram(this.getId());
+			GlStateManager._glUseProgram(getProgramId());
 		}
+
+		int i = GlStateManager._getActiveTexture();
+
+		GlStateManager._activeTexture(i);
 
 		if (intensitySwizzle) {
 			IrisRenderSystem.texParameteriv(RenderSystem.getShaderTexture(0), TextureType.TEXTURE_2D.getGlType(), ARBTextureSwizzle.GL_TEXTURE_SWIZZLE_RGBA,
@@ -205,7 +219,7 @@
 		}
 	}
 
-	private static Uniform FAKE_UNIFORM = new Uniform("", 1, 2, null);
+	private static Uniform FAKE_UNIFORM = new Uniform("", 1, 2);
 
 	@Nullable
 	@Override
@@ -220,84 +234,58 @@
 		}
 	}
 
+	@Override
+	public void setupUniforms(List<ShaderProgramConfig.Uniform> list, List<ShaderProgramConfig.Sampler> list2) {
+		RenderSystem.assertOnRenderThread();
+		Iterator<?> var3 = list.iterator();
+
+		while(var3.hasNext()) {
+			ShaderProgramConfig.Uniform uniform = (ShaderProgramConfig.Uniform)var3.next();
+			String string = uniform.name();
+			int i = Uniform.glGetUniformLocation(this.getProgramId(), string);
+			if (i != -1) {
+				Uniform uniform2 = this.parseUniformNode(uniform);
+				uniform2.setLocation(i);
+				super.uniforms.add(uniform2);
+				super.uniformsByName.put(string, uniform2);
+			}
+		}
+
+		var3 = list2.iterator();
+
+		while(var3.hasNext()) {
+			ShaderProgramConfig.Sampler sampler = (ShaderProgramConfig.Sampler)var3.next();
+			int j = Uniform.glGetUniformLocation(this.getProgramId(), sampler.name());
+			if (j != -1) {
+				super.samplers.add(sampler);
+				super.samplerLocations.add(j);
+			}
+		}
+
+		this.MODEL_VIEW_MATRIX = super.getUniform("iris_ModelViewMat");
+		this.PROJECTION_MATRIX = super.getUniform("iris_ProjMat");
+		this.TEXTURE_MATRIX = super.getUniform("iris_TextureMat");
+		this.SCREEN_SIZE = this.getUniform("ScreenSize");
+		this.COLOR_MODULATOR = super.getUniform("iris_ColorModulator");
+		this.LIGHT0_DIRECTION = this.getUniform("Light0_Direction");
+		this.LIGHT1_DIRECTION = this.getUniform("Light1_Direction");
+		this.GLINT_ALPHA = this.getUniform("GlintAlpha");
+		this.FOG_START = this.getUniform("FogStart");
+		this.FOG_END = this.getUniform("FogEnd");
+		this.FOG_COLOR = this.getUniform("FogColor");
+		this.FOG_SHAPE = this.getUniform("FogShape");
+		this.LINE_WIDTH = this.getUniform("LineWidth");
+		this.GAME_TIME = this.getUniform("GameTime");
+		this.MODEL_OFFSET = super.getUniform("iris_ModelOffset");
+	}
+
+
 	private void uploadIfNotNull(Uniform uniform) {
 		if (uniform != null) {
 			uniform.upload();
 		}
 	}
 
-	@Override
-	public void attachToProgram() {
-		super.attachToProgram();
-		if (this.geometry != null) {
-			this.geometry.attachToShader(this);
-		}
-		if (this.tessControl != null) {
-			this.tessControl.attachToShader(this);
-		}
-		if (this.tessEval != null) {
-			this.tessEval.attachToShader(this);
-		}
-	}
-
-	@Override
-	public void iris$createExtraShaders(ResourceProvider factory, String name) {
-		factory.getResource(ResourceLocation.fromNamespaceAndPath("minecraft", name + "_geometry.gsh")).ifPresent(geometry -> {
-			try {
-				this.geometry = Program.compileShader(IrisProgramTypes.GEOMETRY, name, geometry.open(), geometry.sourcePackId(), new GlslPreprocessor() {
-					@Nullable
-					@Override
-					public String applyImport(boolean bl, String string) {
-						return null;
-					}
-				});
-				GLDebug.nameObject(KHRDebug.GL_SHADER, this.geometry.getId(), name + "_geometry.gsh");
-			} catch (IOException e) {
-				Iris.logger.error("Failed to create shader program", e);
-			}
-		});
-		factory.getResource(ResourceLocation.fromNamespaceAndPath("minecraft", name + "_tessControl.tcs")).ifPresent(tessControl -> {
-			try {
-				this.tessControl = Program.compileShader(IrisProgramTypes.TESS_CONTROL, name, tessControl.open(), tessControl.sourcePackId(), new GlslPreprocessor() {
-					@Nullable
-					@Override
-					public String applyImport(boolean bl, String string) {
-						return null;
-					}
-				});
-				GLDebug.nameObject(KHRDebug.GL_SHADER, this.tessControl.getId(), name + "_tessControl.tcs");
-			} catch (IOException e) {
-				Iris.logger.error("Failed to create shader program", e);
-			}
-		});
-		factory.getResource(ResourceLocation.fromNamespaceAndPath("minecraft", name + "_tessEval.tes")).ifPresent(tessEval -> {
-			try {
-				this.tessEval = Program.compileShader(IrisProgramTypes.TESS_EVAL, name, tessEval.open(), tessEval.sourcePackId(), new GlslPreprocessor() {
-					@Nullable
-					@Override
-					public String applyImport(boolean bl, String string) {
-						return null;
-					}
-				});
-				GLDebug.nameObject(KHRDebug.GL_SHADER, this.tessEval.getId(), name + "_tessEval.tes");
-			} catch (IOException e) {
-				Iris.logger.error("Failed to create shader program", e);
-			}
-		});
-	}
-
-	public Program getGeometry() {
-		return this.geometry;
-	}
-
-	public Program getTessControl() {
-		return this.tessControl;
-	}
-
-	public Program getTessEval() {
-		return this.tessEval;
-	}
-
 	public boolean hasActiveImages() {
 		return images.getActiveImages() > 0;
 	}
Index: common/src/main/java/net/irisshaders/iris/pipeline/programs/FallbackShader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pipeline/programs/FallbackShader.java b/common/src/main/java/net/irisshaders/iris/pipeline/programs/FallbackShader.java
--- a/common/src/main/java/net/irisshaders/iris/pipeline/programs/FallbackShader.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/pipeline/programs/FallbackShader.java	(date 1724259927796)
@@ -1,7 +1,6 @@
 package net.irisshaders.iris.pipeline.programs;
 
 import com.mojang.blaze3d.platform.GlStateManager;
-import com.mojang.blaze3d.shaders.ProgramManager;
 import com.mojang.blaze3d.shaders.Uniform;
 import com.mojang.blaze3d.systems.RenderSystem;
 import com.mojang.blaze3d.vertex.VertexFormat;
@@ -13,14 +12,14 @@
 import net.irisshaders.iris.samplers.IrisSamplers;
 import net.irisshaders.iris.uniforms.CapturedRenderingState;
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.renderer.ShaderInstance;
+import net.minecraft.client.renderer.CompiledShaderProgram;
 import net.minecraft.server.packs.resources.ResourceProvider;
 import org.jetbrains.annotations.Nullable;
 
 import java.io.IOException;
 import java.util.List;
 
-public class FallbackShader extends ShaderInstance {
+public class FallbackShader extends CompiledShaderProgram {
 	private final IrisRenderingPipeline parent;
 	private final BlendModeOverride blendModeOverride;
 	private final GlFramebuffer writingToBeforeTranslucent;
@@ -35,10 +34,10 @@
 	private final int overlay;
 	private final int lightmap;
 
-	public FallbackShader(ResourceProvider resourceFactory, String string, VertexFormat vertexFormat,
+	public FallbackShader(int programId, ResourceProvider resourceFactory, String string, VertexFormat vertexFormat,
 						  GlFramebuffer writingToBeforeTranslucent, GlFramebuffer writingToAfterTranslucent,
 						  BlendModeOverride blendModeOverride, float alphaValue, IrisRenderingPipeline parent) throws IOException {
-		super(resourceFactory, string, vertexFormat);
+		super(programId);
 
 		this.parent = parent;
 		this.blendModeOverride = blendModeOverride;
@@ -48,9 +47,9 @@
 		this.FOG_DENSITY = this.getUniform("FogDensity");
 		this.FOG_IS_EXP2 = this.getUniform("FogIsExp2");
 
-		this.gtexture = GlStateManager._glGetUniformLocation(getId(), "gtexture");
-		this.overlay = GlStateManager._glGetUniformLocation(getId(), "overlay");
-		this.lightmap = GlStateManager._glGetUniformLocation(getId(), "lightmap");
+		this.gtexture = GlStateManager._glGetUniformLocation(programId, "gtexture");
+		this.overlay = GlStateManager._glGetUniformLocation(programId, "overlay");
+		this.lightmap = GlStateManager._glGetUniformLocation(programId, "lightmap");
 
 
 		Uniform ALPHA_TEST_VALUE = this.getUniform("AlphaTestValue");
@@ -89,7 +88,7 @@
 		IrisRenderSystem.bindTextureToUnit(TextureType.TEXTURE_2D.getGlType(), IrisSamplers.OVERLAY_TEXTURE_UNIT, RenderSystem.getShaderTexture(1));
 		IrisRenderSystem.bindTextureToUnit(TextureType.TEXTURE_2D.getGlType(), IrisSamplers.LIGHTMAP_TEXTURE_UNIT, RenderSystem.getShaderTexture(2));
 
-		ProgramManager.glUseProgram(this.getId());
+		GlStateManager._glUseProgram(this.getProgramId());
 
 		List<Uniform> uniformList = super.uniforms;
 		for (Uniform uniform : uniformList) {
Index: common/src/main/resources/mixins.iris.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/resources/mixins.iris.json b/common/src/main/resources/mixins.iris.json
--- a/common/src/main/resources/mixins.iris.json	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/resources/mixins.iris.json	(date 1724261208519)
@@ -44,10 +44,9 @@
     "MixinOptions_Entrypoint",
     "MixinParticleEngine",
     "MixinProgram",
-    "MixinProgramManager",
-    "MixinProgramType",
     "MixinQuickPlayDev",
     "MixinRenderSystem",
+    "MixinRenderSystem_Overrides",
     "MixinRenderTarget",
     "MixinScreenEffectRenderer",
     "MixinShaderInstance",
@@ -57,7 +56,6 @@
     "MixinUniform",
     "MixinVertexBuffer",
     "MixinWindow",
-    "ProgramTypeAccessor",
     "entity_render_context.MixinBlockEntityRenderDispatcher",
     "entity_render_context.MixinCapeLayer",
     "entity_render_context.MixinElytraLayer",
Index: common/src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinLevelRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinLevelRenderer.java b/common/src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinLevelRenderer.java
--- a/common/src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinLevelRenderer.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/batchedentityrendering/mixin/MixinLevelRenderer.java	(date 1724260463409)
@@ -18,6 +18,7 @@
 import net.minecraft.client.renderer.LightTexture;
 import net.minecraft.client.renderer.MultiBufferSource;
 import net.minecraft.client.renderer.RenderBuffers;
+import net.minecraft.client.renderer.culling.Frustum;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.phys.Vec3;
@@ -76,8 +77,8 @@
 		}
 	}
 
-	@Inject(method = "method_62214", at = @At(value = "CONSTANT", args = "stringValue=translucent"), locals = LocalCapture.CAPTURE_FAILHARD)
-	private void batchedentityrendering$beginTranslucents(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, ResourceHandle resourceHandle5, CallbackInfo ci, float f, Vec3 vec3, double d, double e, double g, PoseStack poseStack, MultiBufferSource.BufferSource bufferSource) {
+	@Inject(method = "method_62214", at = @At(value = "CONSTANT", args = "stringValue=translucent"))
+	private void batchedentityrendering$beginTranslucents(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, Frustum frustum, ResourceHandle resourceHandle5, CallbackInfo ci) {
 		if (renderBuffers.bufferSource() instanceof FullyBufferedMultiBufferSource fullyBufferedMultiBufferSource) {
 			fullyBufferedMultiBufferSource.readyUp();
 		}
@@ -98,7 +99,7 @@
 
 
 	@Inject(method = "method_62214", at = @At(value = "CONSTANT", args = "stringValue=translucent", shift = At.Shift.AFTER), locals = LocalCapture.CAPTURE_FAILHARD)
-	private void batchedentityrendering$endTranslucents(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, ResourceHandle resourceHandle5, CallbackInfo ci, float f, Vec3 vec3, double d, double e, double g, PoseStack poseStack, MultiBufferSource.BufferSource bufferSource) {
+	private void batchedentityrendering$endTranslucents(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, Frustum frustum, ResourceHandle resourceHandle5, CallbackInfo ci) {
 		if (WorldRenderingSettings.INSTANCE.shouldSeparateEntityDraws()) {
 			this.renderBuffers.bufferSource().endBatch();
 		}
Index: common/src/main/java/net/irisshaders/iris/mixin/GameRendererAccessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/GameRendererAccessor.java b/common/src/main/java/net/irisshaders/iris/mixin/GameRendererAccessor.java
--- a/common/src/main/java/net/irisshaders/iris/mixin/GameRendererAccessor.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/GameRendererAccessor.java	(date 1724260273579)
@@ -11,8 +11,6 @@
 
 @Mixin(GameRenderer.class)
 public interface GameRendererAccessor {
-	@Accessor
-	PostChain getBlurEffect();
 
 	@Accessor
 	CrossFrameResourcePool getResourcePool();
Index: common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderAccess.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderAccess.java b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderAccess.java
--- a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderAccess.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderAccess.java	(date 1724260186543)
@@ -8,8 +8,10 @@
 import net.irisshaders.iris.pipeline.ShaderRenderingPipeline;
 import net.irisshaders.iris.pipeline.WorldRenderingPipeline;
 import net.irisshaders.iris.shadows.ShadowRenderingState;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.CompiledShaderProgram;
+import net.minecraft.client.renderer.CoreShaders;
 import net.minecraft.client.renderer.GameRenderer;
-import net.minecraft.client.renderer.ShaderInstance;
 
 public class ShaderAccess {
 	public static VertexFormat IE_FORMAT = VertexFormat.builder()
@@ -20,21 +22,21 @@
 		.padding(1)
 		.build();
 
-	public static ShaderInstance getParticleTranslucentShader() {
+	public static CompiledShaderProgram getParticleTranslucentShader() {
 		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
 
 		if (pipeline instanceof ShaderRenderingPipeline) {
-			ShaderInstance override = ((ShaderRenderingPipeline) pipeline).getShaderMap().getShader(ShaderKey.PARTICLES_TRANS);
+			CompiledShaderProgram override = ((ShaderRenderingPipeline) pipeline).getShaderMap().getShader(ShaderKey.PARTICLES_TRANS);
 
 			if (override != null) {
 				return override;
 			}
 		}
 
-		return GameRenderer.getParticleShader();
+		return Minecraft.getInstance().getShaderManager().getProgram(CoreShaders.PARTICLE);
 	}
 
-	public static ShaderInstance getIEVBOShader() {
+	public static CompiledShaderProgram getIEVBOShader() {
 		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
 
 		if (pipeline instanceof ShaderRenderingPipeline) {
@@ -45,7 +47,7 @@
 		return null;
 	}
 
-    public static ShaderInstance getMekanismFlameShader() {
+    public static CompiledShaderProgram getMekanismFlameShader() {
 		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
 
 		if (pipeline instanceof ShaderRenderingPipeline) {
@@ -53,16 +55,16 @@
 			return ((ShaderRenderingPipeline) pipeline).getShaderMap().getShader(ShadowRenderingState.areShadowsCurrentlyBeingRendered() ? ShaderKey.MEKANISM_FLAME_SHADOW : ShaderKey.MEKANISM_FLAME);
 		}
 
-		return GameRenderer.getPositionTexColorShader();
+		return Minecraft.getInstance().getShaderManager().getProgram(CoreShaders.POSITION_TEX_COLOR);
     }
 
-    public static ShaderInstance getMekasuitShader() {
+    public static CompiledShaderProgram getMekasuitShader() {
 		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
 
 		if (pipeline instanceof ShaderRenderingPipeline) {
 			return ((ShaderRenderingPipeline) pipeline).getShaderMap().getShader(ShadowRenderingState.areShadowsCurrentlyBeingRendered() ? ShaderKey.SHADOW_ENTITIES_CUTOUT : ShaderKey.ENTITIES_TRANSLUCENT);
 		}
 
-		return GameRenderer.getRendertypeEntityCutoutShader();
+		return Minecraft.getInstance().getShaderManager().getProgram(CoreShaders.RENDERTYPE_ENTITY_CUTOUT);
     }
 }
Index: common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderCreator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderCreator.java b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderCreator.java
--- a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderCreator.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderCreator.java	(date 1724265234299)
@@ -2,8 +2,14 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.primitives.Ints;
+import com.mojang.blaze3d.platform.GlStateManager;
+import com.mojang.blaze3d.shaders.CompiledShader;
 import com.mojang.blaze3d.vertex.DefaultVertexFormat;
 import com.mojang.blaze3d.vertex.VertexFormat;
+import net.irisshaders.iris.Iris;
+import net.irisshaders.iris.gl.IrisRenderSystem;
+import net.irisshaders.iris.gl.shader.ShaderCompileException;
+import net.irisshaders.iris.gl.shader.ShaderType;
 import net.irisshaders.iris.platform.IrisPlatformHelpers;
 import net.irisshaders.iris.gl.blending.AlphaTest;
 import net.irisshaders.iris.gl.blending.BlendModeOverride;
@@ -25,6 +31,8 @@
 import net.irisshaders.iris.uniforms.builtin.BuiltinReplacementUniforms;
 import net.irisshaders.iris.uniforms.custom.CustomUniforms;
 import net.irisshaders.iris.platform.IrisPlatformHelpers;
+import net.minecraft.client.renderer.CompiledShaderProgram;
+import net.minecraft.client.renderer.ShaderManager;
 import net.minecraft.network.chat.Component;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.PackLocationInfo;
@@ -34,6 +42,7 @@
 import net.minecraft.server.packs.resources.Resource;
 import net.minecraft.server.packs.resources.ResourceProvider;
 import org.apache.commons.io.IOUtils;
+import org.lwjgl.opengl.GL20C;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
@@ -131,7 +140,14 @@
 			}
 		});
 
-		return new ExtendedShader(shaderResourceFactory, name, vertexFormat, tessControl != null || tessEval != null, writingToBeforeTranslucent, writingToAfterTranslucent, blendModeOverride, alpha, uniforms -> {
+		int id = 0;
+		try {
+			id = link(name, vertex, geometry, tessControl, tessEval, fragment, vertexFormat);
+		} catch (ShaderManager.CompilationException e) {
+			throw new RuntimeException(e);
+		}
+
+		return new ExtendedShader(id, shaderResourceFactory, name, vertexFormat, tessControl != null || tessEval != null, writingToBeforeTranslucent, writingToAfterTranslucent, blendModeOverride, alpha, uniforms -> {
 			CommonUniforms.addDynamicUniforms(uniforms, FogMode.PER_VERTEX);
 			customUniforms.assignTo(uniforms);
 			BuiltinReplacementUniforms.addBuiltinReplacementUniforms(uniforms);
@@ -141,6 +157,61 @@
 		}, isIntensity, parent, overrides, customUniforms);
 	}
 
+
+
+	public static int link(String name, String vertex, String geometry, String tessControl, String tessEval, String fragment, VertexFormat vertexFormat) throws ShaderManager.CompilationException {
+		int i = GlStateManager.glCreateProgram();
+		if (i <= 0) {
+			throw new ShaderManager.CompilationException("Could not create shader program (returned program ID " + i + ")");
+		} else {
+			((VertexFormatExtension) vertexFormat).bindAttributesIris(i);
+			GlStateManager.glAttachShader(i, createShader(name, ShaderType.VERTEX, vertex));
+
+			if (geometry != null) {
+				GlStateManager.glAttachShader(i, createShader(name, ShaderType.GEOMETRY, geometry));
+			}
+
+			if (tessControl != null) {
+				GlStateManager.glAttachShader(i, createShader(name, ShaderType.TESSELATION_CONTROL, tessControl));
+			}
+
+			if (tessEval != null) {
+				GlStateManager.glAttachShader(i, createShader(name, ShaderType.TESSELATION_EVAL, tessEval));
+			}
+
+			GlStateManager.glAttachShader(i, createShader(name, ShaderType.FRAGMENT, fragment));
+			GlStateManager.glLinkProgram(i);
+			int j = GlStateManager.glGetProgrami(i, 35714);
+			if (j == 0) {
+				String string = GlStateManager.glGetProgramInfoLog(i, 32768);
+				throw new ShaderManager.CompilationException(
+					"Error encountered when linking program containing VS and FS. Log output: " + string
+				);
+			} else {
+				return i;
+			}
+		}
+	}
+
+	private static int createShader(String name, ShaderType shaderType, String source) {
+		int shader = GlStateManager.glCreateShader(shaderType.id);
+		GlStateManager.glShaderSource(shader, source);
+		GlStateManager.glCompileShader(shader);
+		String log = IrisRenderSystem.getShaderInfoLog(shader);
+
+		if (!log.isEmpty()) {
+			Iris.logger.warn("Shader compilation log for " + name + ": " + log);
+		}
+
+		int result = GlStateManager.glGetShaderi(shader, GL20C.GL_COMPILE_STATUS);
+
+		if (result != GL20C.GL_TRUE) {
+			throw new ShaderCompileException(name, log);
+		}
+
+		return shader;
+	}
+
 	public static FallbackShader createFallback(String name, GlFramebuffer writingToBeforeTranslucent,
 												GlFramebuffer writingToAfterTranslucent, AlphaTest alpha,
 												VertexFormat vertexFormat, BlendModeOverride blendModeOverride,
@@ -198,7 +269,8 @@
 
 		ResourceProvider shaderResourceFactory = new IrisProgramResourceFactory(shaderJsonString, vertex, null, null, null, fragment);
 
-		return new FallbackShader(shaderResourceFactory, name, vertexFormat, writingToBeforeTranslucent,
+		// TODO 24w34a FALLBACK
+		return new FallbackShader(0, shaderResourceFactory, name, vertexFormat, writingToBeforeTranslucent,
 			writingToAfterTranslucent, blendModeOverride, alpha.reference(), parent);
 	}
 
Index: common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderMap.java b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderMap.java
--- a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderMap.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderMap.java	(date 1724259927733)
@@ -1,28 +1,28 @@
 package net.irisshaders.iris.pipeline.programs;
 
-import net.minecraft.client.renderer.ShaderInstance;
+import net.minecraft.client.renderer.CompiledShaderProgram;
 
 import java.util.function.Function;
 
 /**
- * A specialized map mapping {@link ShaderKey} to {@link ShaderInstance}.
+ * A specialized map mapping {@link ShaderKey} to {@link CompiledShaderProgram}.
  * Avoids much of the complexity / overhead of an EnumMap while ultimately
  * fulfilling the same function.
  */
 public class ShaderMap {
-	private final ShaderInstance[] shaders;
+	private final CompiledShaderProgram[] shaders;
 
-	public ShaderMap(Function<ShaderKey, ShaderInstance> factory) {
+	public ShaderMap(Function<ShaderKey, CompiledShaderProgram> factory) {
 		ShaderKey[] ids = ShaderKey.values();
 
-		this.shaders = new ShaderInstance[ids.length];
+		this.shaders = new CompiledShaderProgram[ids.length];
 
 		for (int i = 0; i < ids.length; i++) {
 			this.shaders[i] = factory.apply(ids[i]);
 		}
 	}
 
-	public ShaderInstance getShader(ShaderKey id) {
+	public CompiledShaderProgram getShader(ShaderKey id) {
 		return shaders[id.ordinal()];
 	}
 }
Index: common/src/main/java/net/irisshaders/iris/mixin/vertices/MixinVertexFormat.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/vertices/MixinVertexFormat.java b/common/src/main/java/net/irisshaders/iris/mixin/vertices/MixinVertexFormat.java
--- a/common/src/main/java/net/irisshaders/iris/mixin/vertices/MixinVertexFormat.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/vertices/MixinVertexFormat.java	(date 1724262921543)
@@ -1,20 +1,28 @@
 package net.irisshaders.iris.mixin.vertices;
 
+import com.mojang.blaze3d.platform.GlStateManager;
 import com.mojang.blaze3d.vertex.DefaultVertexFormat;
 import com.mojang.blaze3d.vertex.VertexFormat;
+import net.irisshaders.iris.pipeline.programs.VertexFormatExtension;
 import net.irisshaders.iris.shaderpack.materialmap.WorldRenderingSettings;
 import net.irisshaders.iris.vertices.ImmediateState;
 import net.irisshaders.iris.vertices.IrisVertexFormats;
 import org.spongepowered.asm.mixin.Mixin;
+import org.spongepowered.asm.mixin.Shadow;
 import org.spongepowered.asm.mixin.injection.At;
 import org.spongepowered.asm.mixin.injection.Inject;
 import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
 
+import java.util.List;
+
 /**
  * Ensures that the correct state for the extended vertex format is set up when needed.
  */
 @Mixin(VertexFormat.class)
-public class MixinVertexFormat {
+public abstract class MixinVertexFormat implements VertexFormatExtension {
+	@Shadow
+	public abstract List<String> getElementAttributeNames();
+
 	@Inject(method = "setupBufferState", at = @At("HEAD"), cancellable = true)
 	private void iris$onSetupBufferState(CallbackInfo ci) {
 		if (WorldRenderingSettings.INSTANCE.shouldUseExtendedVertexFormat() && ImmediateState.renderWithExtendedVertexFormat) {
@@ -52,4 +60,14 @@
 			}
 		}
 	}
+
+	@Override
+	public void bindAttributesIris(int i) {
+		int j = 0;
+
+		for (String string : this.getElementAttributeNames()) {
+			GlStateManager._glBindAttribLocation(i, j, "iris_" + string);
+			j++;
+		}
+	}
 }
Index: common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderOverrides.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderOverrides.java b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderOverrides.java
new file mode 100644
--- /dev/null	(date 1724270408113)
+++ b/common/src/main/java/net/irisshaders/iris/pipeline/programs/ShaderOverrides.java	(date 1724270408113)
@@ -0,0 +1,71 @@
+package net.irisshaders.iris.pipeline.programs;
+
+import net.irisshaders.iris.Iris;
+import net.irisshaders.iris.pipeline.IrisRenderingPipeline;
+import net.irisshaders.iris.pipeline.WorldRenderingPhase;
+import net.irisshaders.iris.pipeline.WorldRenderingPipeline;
+import net.irisshaders.iris.shadows.ShadowRenderer;
+
+public class ShaderOverrides {
+	public static ShaderKey getSkyShader(IrisRenderingPipeline pipeline) {
+		if (isSky(pipeline)) {
+			return ShaderKey.SKY_BASIC;
+		} else {
+			return ShaderKey.BASIC;
+		}
+	}
+
+	public static ShaderKey getSkyTexShader(IrisRenderingPipeline pipeline) {
+		if (isSky(pipeline)) {
+			return ShaderKey.SKY_TEXTURED;
+		} else {
+			return ShaderKey.TEXTURED;
+		}
+	}
+
+	public static ShaderKey getSkyTexColorShader(IrisRenderingPipeline pipeline) {
+		if (isSky(pipeline)) {
+			return ShaderKey.SKY_TEXTURED_COLOR;
+		} else {
+			return ShaderKey.TEXTURED_COLOR;
+		}
+	}
+
+	public static ShaderKey getSkyColorShader(IrisRenderingPipeline pipeline) {
+		if (isSky(pipeline)) {
+			return ShaderKey.SKY_BASIC_COLOR;
+		} else {
+			return ShaderKey.BASIC_COLOR;
+		}
+	}
+
+	public static boolean isBlockEntities(IrisRenderingPipeline pipeline) {
+		return pipeline != null && pipeline.getPhase() == WorldRenderingPhase.BLOCK_ENTITIES;
+	}
+
+	public static boolean isEntities(IrisRenderingPipeline pipeline) {
+		return pipeline != null && pipeline.getPhase() == WorldRenderingPhase.ENTITIES;
+	}
+
+	public static boolean isSky(IrisRenderingPipeline pipeline) {
+		if (pipeline != null) {
+			return switch (pipeline.getPhase()) {
+				case CUSTOM_SKY, SKY, SUNSET, SUN, STARS, VOID, MOON -> true;
+				default -> false;
+			};
+		} else {
+			return false;
+		}
+	}
+
+	// ignored: getRendertypeEndGatewayShader (we replace the end portal rendering for shaders)
+	// ignored: getRendertypeEndPortalShader (we replace the end portal rendering for shaders)
+
+	public static boolean isPhase(IrisRenderingPipeline pipeline, WorldRenderingPhase phase) {
+		if (pipeline != null) {
+			return pipeline.getPhase() == phase;
+		} else {
+			return false;
+		}
+	}
+}
Index: fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinLevelRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinLevelRenderer.java b/fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinLevelRenderer.java
--- a/fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinLevelRenderer.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinLevelRenderer.java	(date 1724260484126)
@@ -49,7 +49,7 @@
 	}
 
 	@Inject(method = "method_62214", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/RenderBuffers;crumblingBufferSource()Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;"))
-	private void iris$renderOpaqueParticles(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, ResourceHandle resourceHandle5, CallbackInfo ci) {
+	private void iris$renderOpaqueParticles(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, Frustum frustum, ResourceHandle resourceHandle5, CallbackInfo ci) {
 		minecraft.getProfiler().popPush("opaque_particles");
 
 		ParticleRenderingSettings settings = getRenderingSettings();
Index: common/src/main/java/net/irisshaders/iris/gl/program/Program.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/gl/program/Program.java b/common/src/main/java/net/irisshaders/iris/gl/program/Program.java
--- a/common/src/main/java/net/irisshaders/iris/gl/program/Program.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/gl/program/Program.java	(date 1724270957729)
@@ -1,7 +1,6 @@
 package net.irisshaders.iris.gl.program;
 
 import com.mojang.blaze3d.platform.GlStateManager;
-import com.mojang.blaze3d.shaders.ProgramManager;
 import net.irisshaders.iris.gl.GlResource;
 import net.irisshaders.iris.gl.IrisRenderSystem;
 import org.lwjgl.opengl.GL43C;
@@ -14,6 +13,10 @@
 	Program(int program, ProgramUniforms uniforms, ProgramSamplers samplers, ProgramImages images) {
 		super(program);
 
+		if (program == 0) {
+			throw new IllegalStateException("Created a program with ID 0 somehow.");
+		}
+
 		this.uniforms = uniforms;
 		this.samplers = samplers;
 		this.images = images;
@@ -22,12 +25,12 @@
 	public static void unbind() {
 		ProgramUniforms.clearActiveUniforms();
 		ProgramSamplers.clearActiveSamplers();
-		ProgramManager.glUseProgram(0);
+		GlStateManager._glUseProgram(0);
 	}
 
 	public void use() {
 		IrisRenderSystem.memoryBarrier(GL43C.GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL43C.GL_TEXTURE_FETCH_BARRIER_BIT | GL43C.GL_SHADER_STORAGE_BARRIER_BIT);
-		ProgramManager.glUseProgram(getGlId());
+		GlStateManager._glUseProgram(getGlId());
 
 		uniforms.update();
 		samplers.update();
Index: fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinParticleEngine.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinParticleEngine.java b/fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinParticleEngine.java
--- a/fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinParticleEngine.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/fabric/src/main/java/net/irisshaders/iris/mixin/fantastic/MixinParticleEngine.java	(date 1724260303643)
@@ -12,7 +12,6 @@
 import net.minecraft.client.particle.ParticleEngine;
 import net.minecraft.client.particle.ParticleRenderType;
 import net.minecraft.client.renderer.LightTexture;
-import net.minecraft.client.renderer.ShaderInstance;
 import org.spongepowered.asm.mixin.Final;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
@@ -75,7 +74,7 @@
 	@Inject(method = "render", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/particle/ParticleRenderType;begin(Lcom/mojang/blaze3d/vertex/Tesselator;Lnet/minecraft/client/renderer/texture/TextureManager;)Lcom/mojang/blaze3d/vertex/BufferBuilder;"))
 	private void iris$changeParticleShader(LightTexture lightTexture, Camera camera, float f, CallbackInfo ci) {
 		if (IrisApi.getInstance().isShaderPackInUse() && phase == ParticleRenderingPhase.TRANSLUCENT) {
-			RenderSystem.setShader(ShaderAccess::getParticleTranslucentShader);
+			RenderSystem.setShader(ShaderAccess.getParticleTranslucentShader());
 		}
 	}
 
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinGameRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinGameRenderer.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinGameRenderer.java
--- a/common/src/main/java/net/irisshaders/iris/mixin/MixinGameRenderer.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/MixinGameRenderer.java	(date 1724270408133)
@@ -2,11 +2,9 @@
 
 import com.google.common.collect.Lists;
 import com.mojang.blaze3d.platform.GlUtil;
-import com.mojang.blaze3d.shaders.Program;
 import com.mojang.blaze3d.vertex.PoseStack;
 import net.irisshaders.iris.Iris;
 import net.irisshaders.iris.api.v0.IrisApi;
-import net.irisshaders.iris.gl.program.IrisProgramTypes;
 import net.irisshaders.iris.pathways.HandRenderer;
 import net.irisshaders.iris.pipeline.ShaderRenderingPipeline;
 import net.irisshaders.iris.pipeline.WorldRenderingPhase;
@@ -24,7 +22,6 @@
 import net.minecraft.client.renderer.ItemInHandRenderer;
 import net.minecraft.client.renderer.MultiBufferSource.BufferSource;
 import net.minecraft.client.renderer.RenderBuffers;
-import net.minecraft.client.renderer.ShaderInstance;
 import net.minecraft.server.packs.resources.ResourceManager;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
@@ -41,294 +38,6 @@
 	@Shadow
 	private boolean renderHand;
 
-	@Inject(method = "getPositionShader", at = @At("HEAD"), cancellable = true)
-	private static void iris$overridePositionShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (isSky()) {
-			override(ShaderKey.SKY_BASIC, cir);
-		} else if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_BASIC, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.BASIC, cir);
-		}
-	}
-
-	@Inject(method = "getPositionColorShader", at = @At("HEAD"), cancellable = true)
-	private static void iris$overridePositionColorShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (isSky()) {
-			override(ShaderKey.SKY_BASIC_COLOR, cir);
-		} else if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_BASIC_COLOR, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.BASIC_COLOR, cir);
-		}
-	}
-
-	@Inject(method = "getPositionTexShader", at = @At("HEAD"), cancellable = true)
-	private static void iris$overridePositionTexShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (isSky()) {
-			override(ShaderKey.SKY_TEXTURED, cir);
-		} else if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_TEX, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.TEXTURED, cir);
-		}
-	}
-
-	@Inject(method = {"getPositionTexColorShader", "getPositionColorTexShader"}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overridePositionTexColorShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (isSky()) {
-			override(ShaderKey.SKY_TEXTURED_COLOR, cir);
-		} else if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_TEX_COLOR, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.TEXTURED_COLOR, cir);
-		}
-	}
-
-	//TODO: check cloud phase
-
-	@Inject(method = {
-		"getParticleShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideParticleShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (isPhase(WorldRenderingPhase.RAIN_SNOW)) {
-			override(ShaderKey.WEATHER, cir);
-		} else if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_PARTICLES, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.PARTICLES, cir);
-		}
-	}
-
-	@Inject(method = "getRendertypeCloudsShader", at = @At("HEAD"), cancellable = true)
-	private static void iris$overridePositionTexColorNormalShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_CLOUDS, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.CLOUDS, cir);
-		}
-	}
-
-	@Inject(method = "getRendertypeSolidShader", at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideSolidShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			// TODO: Wrong program
-			override(ShaderKey.SHADOW_TERRAIN_CUTOUT, cir);
-		} else if (isBlockEntities() || isEntities()) {
-			override(ShaderKey.MOVING_BLOCK, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.TERRAIN_SOLID, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeCutoutShader",
-		"getRendertypeCutoutMippedShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideCutoutShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_TERRAIN_CUTOUT, cir);
-		} else if (isBlockEntities() || isEntities()) {
-			override(ShaderKey.MOVING_BLOCK, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.TERRAIN_CUTOUT, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeTranslucentShader",
-		"getRendertypeTranslucentMovingBlockShader",
-		"getRendertypeTripwireShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideTranslucentShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_TERRAIN_CUTOUT, cir);
-		} else if (isBlockEntities() || isEntities()) {
-			override(ShaderKey.MOVING_BLOCK, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.TERRAIN_TRANSLUCENT, cir);
-		}
-	}
-
-	// TODO: getPositionColorLightmapShader
-
-	@Inject(method = {
-		"getRendertypeEntityCutoutShader",
-		"getRendertypeEntityCutoutNoCullShader",
-		"getRendertypeEntityCutoutNoCullZOffsetShader",
-		"getRendertypeEntityDecalShader",
-		"getRendertypeEntitySmoothCutoutShader",
-		"getRendertypeArmorCutoutNoCullShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideEntityCutoutShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_ENTITIES_CUTOUT, cir);
-		} else if (HandRenderer.INSTANCE.isActive()) {
-			override(HandRenderer.INSTANCE.isRenderingSolid() ? ShaderKey.HAND_CUTOUT_DIFFUSE : ShaderKey.HAND_WATER_DIFFUSE, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.BLOCK_ENTITY_DIFFUSE, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.ENTITIES_CUTOUT_DIFFUSE, cir);
-		}
-	}
-
-	// TODO: getPositionTexLightmapColorShader
-
-	@Inject(method = {
-		"getRendertypeEntityTranslucentShader",
-		"getRendertypeEntityTranslucentCullShader",
-		"getRendertypeItemEntityTranslucentCullShader",
-		"getRendertypeBreezeWindShader",
-		"getRendertypeEntityNoOutlineShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideEntityTranslucentShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_ENTITIES_CUTOUT, cir);
-		} else if (HandRenderer.INSTANCE.isActive()) {
-			override(HandRenderer.INSTANCE.isRenderingSolid() ? ShaderKey.HAND_CUTOUT_DIFFUSE : ShaderKey.HAND_WATER_DIFFUSE, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.BE_TRANSLUCENT, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.ENTITIES_TRANSLUCENT, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeEnergySwirlShader",
-		"getRendertypeEntityShadowShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideEnergySwirlShadowShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_ENTITIES_CUTOUT, cir);
-		} else if (HandRenderer.INSTANCE.isActive()) {
-			override(HandRenderer.INSTANCE.isRenderingSolid() ? ShaderKey.HAND_CUTOUT : ShaderKey.HAND_TRANSLUCENT, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.BLOCK_ENTITY, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.ENTITIES_CUTOUT, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeGlintShader",
-		"getRendertypeGlintDirectShader",
-		"getRendertypeGlintTranslucentShader",
-		"getRendertypeArmorGlintShader",
-		"getRendertypeEntityGlintDirectShader",
-		"getRendertypeEntityGlintShader",
-		"getRendertypeArmorEntityGlintShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideGlintShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (shouldOverrideShaders()) {
-			override(ShaderKey.GLINT, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeEntitySolidShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideEntitySolidDiffuseShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_ENTITIES_CUTOUT, cir);
-		} else if (HandRenderer.INSTANCE.isActive()) {
-			override(HandRenderer.INSTANCE.isRenderingSolid() ? ShaderKey.HAND_CUTOUT_DIFFUSE : ShaderKey.HAND_WATER_DIFFUSE, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.BLOCK_ENTITY_DIFFUSE, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.ENTITIES_SOLID_DIFFUSE, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeWaterMaskShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideEntitySolidShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_ENTITIES_CUTOUT, cir);
-		} else if (HandRenderer.INSTANCE.isActive()) {
-			override(HandRenderer.INSTANCE.isRenderingSolid() ? ShaderKey.HAND_CUTOUT : ShaderKey.HAND_TRANSLUCENT, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.BLOCK_ENTITY, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.ENTITIES_SOLID, cir);
-		}
-	}
-
-	@Inject(method = "getRendertypeBeaconBeamShader", at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideBeaconBeamShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_BEACON_BEAM, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.BEACON, cir);
-		}
-	}
-
-	@Inject(method = "getRendertypeEntityAlphaShader", at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideEntityAlphaShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (!ShadowRenderer.ACTIVE) {
-			override(ShaderKey.ENTITIES_ALPHA, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeEyesShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideEntityEyesShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_ENTITIES_CUTOUT, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.BLOCK_ENTITY, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.ENTITIES_EYES, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeEntityTranslucentEmissiveShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideEntityTranslucentEmissiveShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			// TODO: Wrong program
-			override(ShaderKey.SHADOW_ENTITIES_CUTOUT, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.BLOCK_ENTITY, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.ENTITIES_EYES_TRANS, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeLeashShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideLeashShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_LEASH, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.LEASH, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeLightningShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideLightningShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_LIGHTNING, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.LIGHTNING, cir);
-		}
-	}
-	// NOTE: getRenderTypeOutlineShader should not be overriden.
-
-	@Inject(method = {
-		"getRendertypeCrumblingShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideCrumblingShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (shouldOverrideShaders() && !ShadowRenderer.ACTIVE) {
-			override(ShaderKey.CRUMBLING, cir);
-		}
-	}
-
 	@Inject(method = "render", at = @At("HEAD"))
 	private void iris$startFrame(DeltaTracker deltaTracker, boolean bl, CallbackInfo ci) {
 		// This allows certain functions like float smoothing to function outside a world.
@@ -337,122 +46,6 @@
 		SystemTimeUniforms.TIMER.beginFrame(Util.getNanos());
 	}
 
-	@Inject(method = {
-		"getRendertypeTextShader",
-		"getRendertypeTextSeeThroughShader",
-		"getPositionColorTexLightmapShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideTextShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_TEXT, cir);
-		} else if (HandRenderer.INSTANCE.isActive()) {
-			override(ShaderKey.HAND_TEXT, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.TEXT_BE, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.TEXT, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeTextBackgroundShader",
-		"getRendertypeTextBackgroundSeeThroughShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideTextBackgroundShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_TEXT_BG, cir);
-		} else {
-			override(ShaderKey.TEXT_BG, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeTextIntensityShader",
-		"getRendertypeTextIntensitySeeThroughShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideTextIntensityShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_TEXT_INTENSITY, cir);
-		} else if (HandRenderer.INSTANCE.isActive()) {
-			override(ShaderKey.HAND_TEXT_INTENSITY, cir);
-		} else if (isBlockEntities()) {
-			override(ShaderKey.TEXT_INTENSITY_BE, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.TEXT_INTENSITY, cir);
-		}
-	}
-
-	@Inject(method = {
-		"getRendertypeLinesShader"
-	}, at = @At("HEAD"), cancellable = true)
-	private static void iris$overrideLinesShader(CallbackInfoReturnable<ShaderInstance> cir) {
-		if (ShadowRenderer.ACTIVE) {
-			override(ShaderKey.SHADOW_LINES, cir);
-		} else if (shouldOverrideShaders()) {
-			override(ShaderKey.LINES, cir);
-		}
-	}
-
-	private static boolean isBlockEntities() {
-		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
-
-		return pipeline != null && pipeline.getPhase() == WorldRenderingPhase.BLOCK_ENTITIES;
-	}
-
-	private static boolean isEntities() {
-		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
-
-		return pipeline != null && pipeline.getPhase() == WorldRenderingPhase.ENTITIES;
-	}
-
-	private static boolean isSky() {
-		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
-
-		if (pipeline != null) {
-			return switch (pipeline.getPhase()) {
-				case CUSTOM_SKY, SKY, SUNSET, SUN, STARS, VOID, MOON -> true;
-				default -> false;
-			};
-		} else {
-			return false;
-		}
-	}
-
-	// ignored: getRendertypeEndGatewayShader (we replace the end portal rendering for shaders)
-	// ignored: getRendertypeEndPortalShader (we replace the end portal rendering for shaders)
-
-	private static boolean isPhase(WorldRenderingPhase phase) {
-		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
-
-		if (pipeline != null) {
-			return pipeline.getPhase() == phase;
-		} else {
-			return false;
-		}
-	}
-
-	private static boolean shouldOverrideShaders() {
-		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
-
-		if (pipeline instanceof ShaderRenderingPipeline) {
-			return ((ShaderRenderingPipeline) pipeline).shouldOverrideShaders();
-		} else {
-			return false;
-		}
-	}
-
-	private static void override(ShaderKey key, CallbackInfoReturnable<ShaderInstance> cir) {
-		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
-
-		if (pipeline instanceof ShaderRenderingPipeline) {
-			ShaderInstance override = ((ShaderRenderingPipeline) pipeline).getShaderMap().getShader(key);
-
-			if (override != null) {
-				cir.setReturnValue(override);
-			}
-		}
-	}
-
 	@Inject(method = "<init>", at = @At("TAIL"))
 	private void iris$logSystem(Minecraft arg, ItemInHandRenderer arg2, ResourceManager arg3, RenderBuffers arg4, CallbackInfo ci) {
 		Iris.logger.info("Hardware information:");
@@ -474,13 +67,4 @@
 	private void iris$runColorSpace(DeltaTracker deltaTracker, CallbackInfo ci) {
 		Iris.getPipelineManager().getPipeline().ifPresent(WorldRenderingPipeline::finalizeGameRendering);
 	}
-
-	@Redirect(method = "reloadShaders", at = @At(value = "INVOKE", target = "Lcom/google/common/collect/Lists;newArrayList()Ljava/util/ArrayList;"))
-	private ArrayList<Program> iris$reloadGeometryShaders() {
-		ArrayList<Program> programs = Lists.newArrayList();
-		programs.addAll(IrisProgramTypes.GEOMETRY.getPrograms().values());
-		programs.addAll(IrisProgramTypes.TESS_CONTROL.getPrograms().values());
-		programs.addAll(IrisProgramTypes.TESS_EVAL.getPrograms().values());
-		return programs;
-	}
 }
Index: common/src/main/java/net/irisshaders/iris/gl/program/ComputeProgram.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/gl/program/ComputeProgram.java b/common/src/main/java/net/irisshaders/iris/gl/program/ComputeProgram.java
--- a/common/src/main/java/net/irisshaders/iris/gl/program/ComputeProgram.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/gl/program/ComputeProgram.java	(date 1724259944973)
@@ -1,7 +1,6 @@
 package net.irisshaders.iris.gl.program;
 
 import com.mojang.blaze3d.platform.GlStateManager;
-import com.mojang.blaze3d.shaders.ProgramManager;
 import net.irisshaders.iris.Iris;
 import net.irisshaders.iris.gl.GlResource;
 import net.irisshaders.iris.gl.IrisRenderSystem;
@@ -36,7 +35,7 @@
 
 	public static void unbind() {
 		ProgramUniforms.clearActiveUniforms();
-		ProgramManager.glUseProgram(0);
+		GlStateManager._glUseProgram(0);
 	}
 
 	public void setWorkGroupInfo(Vector2f relativeWorkGroups, Vector3i absoluteWorkGroups, FilledIndirectPointer indirectPointer) {
@@ -65,7 +64,7 @@
 	}
 
 	public void use() {
-		ProgramManager.glUseProgram(getGlId());
+		GlStateManager._glUseProgram(getGlId());
 
 		uniforms.update();
 		samplers.update();
Index: common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/clouds/MixinCloudRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/clouds/MixinCloudRenderer.java b/common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/clouds/MixinCloudRenderer.java
--- a/common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/clouds/MixinCloudRenderer.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/sodiumCompatibility/java/net/irisshaders/iris/compat/sodium/mixin/clouds/MixinCloudRenderer.java	(date 1724260323826)
@@ -11,7 +11,7 @@
 import net.irisshaders.iris.pipeline.WorldRenderingPipeline;
 import net.irisshaders.iris.pipeline.programs.ShaderKey;
 import net.irisshaders.iris.vertices.IrisVertexFormats;
-import net.minecraft.client.renderer.ShaderInstance;
+import net.minecraft.client.renderer.CompiledShaderProgram;
 import org.jetbrains.annotations.Nullable;
 import org.spongepowered.asm.mixin.Mixin;
 import org.spongepowered.asm.mixin.Shadow;
@@ -25,7 +25,7 @@
 @Mixin(CloudRenderer.class)
 public abstract class MixinCloudRenderer {
 	@Shadow
-	private ShaderInstance shaderProgram;
+	private CompiledShaderProgram shaderProgram;
 	@Shadow
 	@Nullable
 	private CloudRenderer.@Nullable CloudGeometry cachedGeometry;
@@ -58,8 +58,8 @@
 		}
 	}
 
-	@Redirect(method = "render", at = @At(value = "FIELD", target = "Lnet/caffeinemc/mods/sodium/client/render/immediate/CloudRenderer;shaderProgram:Lnet/minecraft/client/renderer/ShaderInstance;"))
-	private ShaderInstance changeShader(CloudRenderer instance) {
+	@Redirect(method = "render", at = @At(value = "FIELD", target = "Lnet/caffeinemc/mods/sodium/client/render/immediate/CloudRenderer;shaderProgram:Lnet/minecraft/client/renderer/CompiledShaderProgram;"))
+	private CompiledShaderProgram changeShader(CloudRenderer instance) {
 		return getClouds();
 	}
 
@@ -96,7 +96,7 @@
 		}
 	}
 
-	private ShaderInstance getClouds() {
+	private CompiledShaderProgram getClouds() {
 		WorldRenderingPipeline pipeline = Iris.getPipelineManager().getPipelineNullable();
 
 		if (pipeline instanceof ShaderRenderingPipeline) {
Index: common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer.java b/common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer.java
--- a/common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixin/MixinLevelRenderer.java	(date 1724258482409)
@@ -26,6 +26,7 @@
 import net.minecraft.client.DeltaTracker;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.multiplayer.ClientLevel;
+import net.minecraft.client.renderer.CoreShaders;
 import net.minecraft.client.renderer.DimensionSpecialEffects;
 import net.minecraft.client.renderer.FogParameters;
 import net.minecraft.client.renderer.GameRenderer;
@@ -171,7 +172,7 @@
 		// We've changed the phase, but vanilla doesn't update the shader program at this point before rendering stuff,
 		// so we need to manually refresh the shader program so that the correct shader override gets applied.
 		// TODO: Move the injection instead
-		RenderSystem.setShader(GameRenderer::getPositionShader);
+		RenderSystem.setShader(CoreShaders.POSITION);
 	}
 
 	@Inject(method = "method_62215", at = @At(value = "RETURN"))
@@ -180,12 +181,12 @@
 	}
 
 	@Inject(method = "method_62205", at = @At(value = "HEAD"))
-	private void iris$beginClouds(ResourceHandle resourceHandle, int i, CloudStatus cloudStatus, float f, Matrix4f matrix4f, Matrix4f matrix4f2, Vec3 vec3, float g, CallbackInfo ci) {
+	private void iris$beginClouds(ResourceHandle<?> resourceHandle, int i, CloudStatus cloudStatus, float f, Matrix4f matrix4f, Matrix4f matrix4f2, Vec3 vec3, float g, CallbackInfo ci) {
 		pipeline.setPhase(WorldRenderingPhase.CLOUDS);
 	}
 
 	@Inject(method = "method_62205", at = @At("RETURN"))
-	private void iris$endClouds(ResourceHandle resourceHandle, int i, CloudStatus cloudStatus, float f, Matrix4f matrix4f, Matrix4f matrix4f2, Vec3 vec3, float g, CallbackInfo ci) {
+	private void iris$endClouds(ResourceHandle<?> resourceHandle, int i, CloudStatus cloudStatus, float f, Matrix4f matrix4f, Matrix4f matrix4f2, Vec3 vec3, float g, CallbackInfo ci) {
 		pipeline.setPhase(WorldRenderingPhase.NONE);
 	}
 
@@ -216,13 +217,13 @@
 		pipeline.setPhase(WorldRenderingPhase.NONE);
 	}
 
-	@Inject(method = "method_62214", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/debug/DebugRenderer;render(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;DDD)V"))
-	private void iris$setDebugRenderStage(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, ResourceHandle resourceHandle5, CallbackInfo ci) {
+	@Inject(method = "method_62214", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/debug/DebugRenderer;render(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/culling/Frustum;Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;DDD)V"))
+	private void iris$setDebugRenderStage(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle<?> resourceHandle, ResourceHandle<?> resourceHandle2, ResourceHandle<?> resourceHandle3, ResourceHandle<?> resourceHandle4, boolean bl, Frustum frustum, ResourceHandle<?> resourceHandle5, CallbackInfo ci) {
 		pipeline.setPhase(WorldRenderingPhase.DEBUG);
 	}
 
-	@Inject(method = "method_62214", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/debug/DebugRenderer;render(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;DDD)V", shift = At.Shift.AFTER))
-	private void iris$resetDebugRenderStage(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, ResourceHandle resourceHandle5, CallbackInfo ci) {
+	@Inject(method = "method_62214", at = @At(value = "INVOKE", target = "Lnet/minecraft/client/renderer/debug/DebugRenderer;render(Lcom/mojang/blaze3d/vertex/PoseStack;Lnet/minecraft/client/renderer/culling/Frustum;Lnet/minecraft/client/renderer/MultiBufferSource$BufferSource;DDD)V", shift = At.Shift.AFTER))
+	private void iris$resetDebugRenderStage(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f matrix4f, Matrix4f matrix4f2, ResourceHandle<?> resourceHandle, ResourceHandle<?> resourceHandle2, ResourceHandle<?> resourceHandle3, ResourceHandle<?> resourceHandle4, boolean bl, Frustum frustum, ResourceHandle<?> resourceHandle5, CallbackInfo ci) {
 		pipeline.setPhase(WorldRenderingPhase.NONE);
 	}
 
@@ -233,7 +234,7 @@
 	}
 
 	@Inject(method = "method_62214", at = @At(value = "CONSTANT", args = "stringValue=translucent"))
-	private void iris$beginTranslucents(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f modelMatrix, Matrix4f matrix4f2, ResourceHandle resourceHandle, ResourceHandle resourceHandle2, ResourceHandle resourceHandle3, ResourceHandle resourceHandle4, boolean bl, ResourceHandle resourceHandle5, CallbackInfo ci) {
+	private void iris$beginTranslucents(FogParameters fogParameters, DeltaTracker deltaTracker, Camera camera, ProfilerFiller profilerFiller, Matrix4f modelMatrix, Matrix4f matrix4f2, ResourceHandle<?> resourceHandle, ResourceHandle<?> resourceHandle2, ResourceHandle<?> resourceHandle3, ResourceHandle<?> resourceHandle4, boolean bl, Frustum frustum, ResourceHandle<?> resourceHandle5, CallbackInfo ci) {
 		pipeline.beginHand();
 		HandRenderer.INSTANCE.renderSolid(modelMatrix, deltaTracker.getGameTimeDeltaPartialTick(true), camera, Minecraft.getInstance().gameRenderer, pipeline);
 		Minecraft.getInstance().getProfiler().popPush("iris_pre_translucent");
Index: common/src/main/java/net/irisshaders/iris/mixinterface/ShaderInstanceInterface.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/common/src/main/java/net/irisshaders/iris/mixinterface/ShaderInstanceInterface.java b/common/src/main/java/net/irisshaders/iris/mixinterface/ShaderInstanceInterface.java
--- a/common/src/main/java/net/irisshaders/iris/mixinterface/ShaderInstanceInterface.java	(revision 8560dd98729c056a5b6f61632bc18a033b6b37be)
+++ b/common/src/main/java/net/irisshaders/iris/mixinterface/ShaderInstanceInterface.java	(date 1724259722689)
@@ -5,5 +5,4 @@
 import java.io.IOException;
 
 public interface ShaderInstanceInterface {
-	void iris$createExtraShaders(ResourceProvider factory, String name) throws IOException;
 }
